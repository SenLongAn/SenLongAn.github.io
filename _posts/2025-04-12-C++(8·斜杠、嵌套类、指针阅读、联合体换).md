---
title: c++(8·嵌套类、指针阅读、联合体、智能指针)
date: 2025-04-12 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---

# 嵌套类

嵌套类：将一个类的定义放到另一个类中，目的在于隐藏类名（限制用户使用该类建立对象），减少全局的标识符，强调主从关系(必须创建A才会有B)

```c++
class A
{
public:
　class B
　{
　};
}

class A
{
};
class B
{
};
```

* 嵌套类与外围类的对象成员具有相同的访问权限规则
* 嵌套类不属于外围类，它们之间不可以直接访问对方的成员，常分解看作非嵌套类来处理

# union

```c++
union name(可选){ // 无名联合体可直接使用变量名，有名的联合体需要创建name类型的对象
	int i; 
	float f; 
};//联合体大小 == 4
union U1 {
	int n;
	char s[11];
	double d;
};//联合体大小 == 16
```

联合体/共用体，它类似于结构体，都可以存储不同数据类型的对象，并且它默认的成员访问修饰符是public的，

但是不同于结构体的内存分配机制，允许在 同一块内存空间 存储不同的数据类型，所有成员共享内存，它所有成员的偏移量都是0，内存地址都相同，union的内存容量取决于最大的成员，内存对齐要考虑所有的成员，

修改一个成员会影响其他成员的值，同一时间只能使用其中一个成员，因为它是最安全的，如果使用非赋值的成员，可能得到垃圾值或程序崩溃

当多个数据每次只取其一时，可以利用联合体，它可以节省内存

# 智能指针

* T* name = new T;
* new创建的指针指向动态生命周期，需要通过delete才能释放内存
* 当内置指针在生命周期结束前忘记释放指向的动态内存，内存会一直存在，容易造成内存泄露
* 如果我们将动态内存交由类对象托管，对象过期调用析构时释放动态内存

### 智能指针常用函数

* get获取托管的指针指向的地址
  * 不要用get初始化/赋值给另一个智能指针，这种非典型的用法并不会增加引用计数，当它们都调用析构，将多次释放同一内存，程序崩溃
  * 不要delete掉get获得的内存，这样智能指针托管的指针变为无效内存，调用析构时，将多次释放同一内存，程序崩溃
* release取消托管，托管指针置为nullptr，动态内存需要手动释放，
  * 要记得手动释放，函数会返回指向原托管的内存的指针
* reset重置托管，
  * 如果参数为空，取消托管, 托管指针置为nullptr，释放托管的内存
  * 如果参数不为空，如果地址不一致，释放掉旧的内存，托管新的内存，如果此内存被其他指针托管，取消旧托管，然后再托管

### auto_ptr（C++11中已弃用）

```c++
#include < memory >
auto_ptr<type> test(new type);

Test *tmp = test.get();	

Test *tmp2 = test.release();
delete tmp2;

test.reset();
test.reset(new Test());

auto_ptr<int[]> array(new int[5]);//❌：不支持管理数组
```

* auto_ptr
  * auto_ptr\<T> name(new T);
  * 不能多个智能指针同时指向同一内存
  * 智能指针生命周期结束释放内存
  * 由于auto_ptr模板类重载了-> 和 * 因此可以像普通指针一样使用
  * 支持拷贝构造，拷贝赋值，允许左值赋值，但内部使用了资源转移，隐式操作非常容易忘记谁的资源被转移（拷贝函数做了移动函数的功能）
  * 已弃用因为：
    * 赋值会转移资源的所有权，当容器T为auto_ptr\<T>时，元素赋值后被转移的元素托管的指针指向nullptr，访问它会出现问题，因此它作为容器T时存在重大风险
    * 不支持管理数组

### unique_ptr

```c++
unique_ptr<string> t1;//创建空对象
unique_ptr<string> p1(new string("hello"));//类模板
p1 = p2;					// ❌：禁止左值拷贝赋值
unique_ptr<string> p3(p2);  // ❌：禁止左值拷贝构造
p1 = std::move(p2);			//✅:
unique_ptr<string> p3(std::move(p1)); //✅:
unique_ptr<int[]> array(new int[5]);//✅:支持管理数组
t9 = nullptr;//释放对象
```

* unique_ptr
  * unique_ptr\<T> name(new T);
  * 不能多个指针同时指向同一内存
  * 智能指针生命周期结束释放内存
  * 它仅支持移动构造，移动赋值，不允许左值赋值，仅支持传递右值，显示操作不容易忘记谁的资源被转移（移动函数做了移动函数的功能）
  * 当容器T为unique_ptr\<T>时，由于不允许左值赋值，因此它作为容器T时是安全的
  * 支持管理数组
  * 使用陷阱，当一个指针托管内存被另一个指针托管，原指针无法访问

### shared_ptr

```c++
shared_ptr<string> sp1;
shared_ptr<string> sp2(new string("hello"));
sp1 = sp2;
shared_ptr<string> sp3(sp1);
shared_ptr<string[]> sp5(new string[5] { 3, 4, 5, 6, 7 });
shared_ptr<int> up3 = make_shared<int>(2);
up1 = nullptr ;//释放对象
```

* shared_ptr
  * shared_ptr\<T> name(new T);
  * 允许多个指针同时指向同一内存
  * 当构造、拷贝构造、拷贝赋值……引用计数++，被赋值、析构……时引用计数--，如果计数为0，释放内存
  * 支持拷贝构造，拷贝赋值，移动构造，移动赋值
  * use_count可以获得当前托管指针的托管内存的引用计数
  * make_shared 初始化对象，分配内存效率更高
  * 支持管理数组
  * 循环引用问题

	```c++
	class A{
		void Set(shared_ptr<B> _b) {
			this->b = _b;
		}
	private:
		shared_ptr<B> b;
	};
	class B{
		void Set(shared_ptr<A> _a) {
			this->a = _a;
		}
	private:
		shared_ptr<A> a;
	};
	void fun(){
		shared_ptr<A> a(new A());//引用计数1
		shared_ptr<B> b(new B());//引用计数1
		a->Set(b);//引用计数2
		b->Set(a);//引用计数2
	}
	int main(void) {
		fun();
		//引用计数1
		//引用计数1
		return 0;
	}
	```

    * 当有AB两类，A包含B类型的智能指针成员，B包含A类型的智能指针成员，且分别托管对方类类型智能指针，
    * 此时A和B托管的动态内存引用计数都是2，当AB类类型智能指针作用域结束，调用析构将托管指针置为空，两个动态内存引用计数--，托管的内存引用计数都变为1，所以动态内存没有被释放
    * 解决方法一（避免出现引用循环）：使用单方面管理，A托管的动态内存引用计数为2，B托管的动态内存引用计数为1，析构将A托管的动态内存引用计数--，B托管的动态内存引用计数--为0，动态内存被释放，成员指针作用域结束，动态内存引用计数--置为0，动态内存都被释放
    * 解决方法二（使用weak_ptr）：

### weak_ptr

```c++
shared_ptr<A> a(new A());
shared_ptr<B> b(new B());
weak_ptr<A> w(a);	// 使用共享指针构造
weak_ptr<B> w1;	// 使用共享指针构造
w1 = b;				// 使用共享指针赋值
shared_ptr<B> b1= w1.lock();
```

* 弱指针 设计目的是为了协助 shared_ptr 工作, 
* 原理：相当于托管了shared_ptr（就像shared_ptr托管动态内存一样）
* 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，
* 没有重载*和->，不能像普通指针一样使用
* lock获得托管的shared_ptr 对象
* use_count可以获得托管的引用计数
* expired判断当前weak_ptr智能指针是否还有托管的对象，有则返回false，无则返回true
* 不会增加/减少引用计数
* 对于循环引用问题：让AB任意一个智能指针成员为weak_ptr，由于不会增加/减少引用计数，和解决方法一原理一致
