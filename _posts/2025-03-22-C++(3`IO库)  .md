---
title: c++(3`I/O库)
date: 2025-03-22 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---
# I/O库

输入和输出并不是C++语言中的正式组成成分，而是在c++ STL（Standard Library标准库，命名空间使用std）中的io库中定义的：

**流(stream)：**

描述字节序列在设备和内存流动的现象

**输入输出：**

![1742627505358](/assets/img/blog/c++/输入输出.png)

如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，是输入操作

如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），是输出操作

## 流运算符

流提取运算符'>>'用于从左侧输入流对象中 提取（意味着缓冲区中数据被转移不存在了）数据 存储到右侧对象中

流插入运算符'<<'用于将右侧对象数据 插入（拷贝） 到左侧输出流对象中

## 输入输出流对象

**分类：**

* 键盘输入数据，输出到显示器屏幕，称为标准的输入输出流对象
* 磁盘文件间的输入输出，称为文件的输入输出流对象
* 内存中指定的空间进行输入和输出，称为字符串输入输出流对象

**标准输入输出流**

```c++
#include <iostream>
```

std::istream：标准输入流类（类类型）

std::ostream：标准输出流类

std::iostream：标准输入输出流类

std::cin 标准输入流对象（类对象）：用于从标准输入读取数据，包含标准输入缓冲区

std::cout 标准输出流对象: 用于将数据输出到标准输出，包含标准输出缓冲区

std::cerr: 标准错误流对象: 用于输出错误信息

std::clog: 标准日志流对象: 用于输出日志信息

_常见形式：_

```c++
#include <iostream>
int x;
std::cin >> x;//从左往右理解 
std::cout << "The answer is " << 42 << std::endl;//从右往左理解

vector<int> nums(5);
for(int i = 0; i < nums.size(); i++) {
    cin >> nums[i];
}
for(int i = 0; i < nums.size(); i++) {
    cout << nums[i] << " ";
}

vector<int> nums;
int num;
while(cin >> num) {
    nums.push_back(num);
    // 读到换行符，终止循环
    if(getchar() == '\n') {
        break;
    }
}

#include <string>
string name1;
getline(cin, name1);

char ch;
ch = getchar();
char arr[20];
cin.get(arr, 20);

stoi(tmp);
```

* 单独读取输出
* 批量读取输出
  * for用来处理固定数量的
  * while处理不固定数量的
* getline 会从输入流中读取整行内容，直到遇到换行符为止，不会忽略读取内容中的空格，并将换行符从缓冲区中移除
* getchar/cin.get() 读取一个char字符，包括空格和换行符,读取多个字符
* cin.ignore( a, ch )计数，字符
  * 函数运行时，忽略提取的字符
  * 如果计数到达a/被忽略的字符为ch，则函数终止，否则继续等待输入
  * cin.ignore(1024, '\n')把第一个参数设置足够大，这样起作用的只有ch，用来清除以回车结束的输入缓冲区的内容
  * 不带参数默认形式为cin.ignore(1, EOF)，即把EOF（文件结束符，ctrl+z）前的1个字符清掉,没有遇到EOF就清掉一个字符然后结束

  ```c++
  //假设输入：
  //3
  //2

  int m, n;
  cin >> m >> n;//√：3，2
  
  int m, n;
  cin >> m;
  //cin.ignore();
  getline(cin, n);//×：2，''
  ```

  * cin读取到\n时会自动跳过，getline读取到\n会终止，返回值忽略\n,返回空，可以用ignore解决这个问题
* stoi将字符串转为整数

**文件输入输出流**

```c++
#include <fstream>
```

std::ifstream：文件输入流类

std::ofstream：文件输出流类

std::fstream：文件输入输出流类

_常见形式：_

说标准输入输出流通常使用自带的cin、count对象，而文件输入输出流通常要自己构建流对象，然后调用类函数

```c++
std::ofstream outFile("example.txt");
is_open()//是否打开
close()//关闭
```

**字符串输入输出流**

```c++
#include <sstream>
```

std::istringstream：字符串输入流类

std::ostringstream：字符串输出流类

std::stringstream：字符串输入输出流类

## 用户处理

**转移字符**

![1742627505358](/assets/img/blog/c++/转义字符.png)

在使用是加''单引号

正斜杠（/）: 支持跨平台

反斜杠（\）：Windows原生路径分隔符, \也是转义前导字符（转义前导字符不仅包括\），用于和后面跟随的字母构成转义字符

如果在转义字符前，应用/反斜杠，则起到避免转义的作用，转义字符会变为多个char

**endl**

缓冲区作用：将数据收集起来，然后一次性提交，避免大量IO操作，从而极大地提升性能

step:

* 换行：在输出流里插入一个换行符'\n', 让下一次的输出在下一行显示
* 刷新缓冲区：将标准输出缓冲区里的内容立即输出到标准输出设备，缓冲区数据清空，立即提交使得我们即时看到输出内容

**科学计数法**

科学记数法：把一个数表示成a与10的n次幂相乘的形式（1≤|a|<10，a不为分数形式，n为整数），例如：20 = 2 × 10¹，作用方便表示由于太大或太小而不能方便地用十进制表示的数（避免写出一串异常长的数字）

计算器：表达10的幂一般是用E或e，例如2E1 = 20

3.843E05=384300，这里05的0可以忽略

1E6+7= 1000007，1*10^6+7

2e+001 = 20，2 * 10^1

**对输出浮点精度控制**

```c++
#include <iomanip>
double s = 20.7843000;
//setprecision：遵守四舍五入，只对浮点数生效，不显示末尾的零
cout << setprecision(1) << s << endl; // 输出 2e+001 (1位有效数字，科学计数法)
cout << setprecision(2) << s << endl; // 输出 21
cout << setprecision(3) << s << endl; // 输出 20.8
cout << setprecision(6) << s << endl; // 输出 20.7843
//fixed：指定小数点后的位数
cout << fixed << setprecision(1) << s << endl; // 输出 20.8
cout << fixed << setprecision(2) << s << endl; // 输出 20.78
cout << fixed << setprecision(6) << s << endl; // 输出 20.784391
//showpoint；强制显示小数点和末尾的零
cout << showpoint << setprecision(2) << s << endl; // 输出 21.   (注意有点)
cout << showpoint << setprecision(7) << s << endl; // 输出 20.78430 (补零)

cout << setw(9) << setfill('0') << n << endl;//setw(9) 用于设置输出宽度为9位，setfill('0') 则指定了不足部分填充的字符为'0'，会在前面补零
```

fixed 和 showpoint 等格式标志一旦设置，会持续影响后续所有的输出

回到默认的浮点格式：cout << defaultfloat;

**printf**

是C库函数，int printf(const char *text, ...)，

text：C风格字符串

附加参数：可变参数，每个参数替换text中一个格式标签，参数的个数应与格式标签的个数相同

![1742627505358](/assets/img/blog/c++/格式标签.png)

![1742627505358](/assets/img/blog/c++/printf.png)

格式标签：%[flags][width][.precision][length][specifier]，标识、宽度、精度、长度、格式字符

**用户输入**

分隔符：

* 用户输入字符串后，以空格、tab、回车（可以理解为仅间隔大小不同,这里应该使用按键，而非转义字符）作为每个数据的分隔符
* cin读取用户时，会忽略前导的空白字符，直到遇到非空白字符开始读取，然后在遇到下一个空白字符时停止读取

推送：

* 按下回车，首先会将字符串送入到标准输入缓冲区，然后回车操作会被转换为一个换行符\n

输入个数：

* 输入不足：cin 会等待用户继续输入，直到满足需要的数据个数(需要的个数为>>个数)
* 输入过多：多余的数据会留在输入缓冲区中，供后续的 cin指令 使用

对while理解：

* 会持续接受用户输入，直到条件为假
  * 按下 Ctrl+D（Linux/Mac）或 Ctrl+Z（Windows），while 条件为假，循环结束
  * 如果用户输入的是无效输入（类型不正确），cin 会进入错误状态，while 条件为假，循环结束

**常用函数和头文件**

```c++
#include <cmath>
abs(x)绝对值
sqrt(x)平方根
pow(x,y)指数x^y
cbrt(x)开三次方
double PI = acos(-1) Π近似
ceil(x)向上取整
floor(x)向下取整
round(x)四舍五入
#include <iomanip>
cout << fixed << setprecision(n) << x << endl; n结果保留几位小数，x需要为浮点类型
#include<algorithm>
sort(begin,end)排序，左闭右开
min(a,b)max(a,b)最小最大值
abs(x)绝对值
#include<cstdlib>
stoi(x)字符串转整数
#include<iostream>
isalpha(c)是否为字母
islower(c)是否为小写
isupper(c)是否为大写
tolower(c)转换为小写
toupper(c)转换为大写
isdigit(c)是否为数字
isalnumic(c)是否为数字/字母
INT_MAX int类型最大值
auto自动推断类型
#include<numeric>
c++14中gcd(a,b)最大公约数lcm(a,b)最小公倍数
c++11中_gcd(a,b)
#include<string>
substr(x,y)截取从x开始y个数
erase(x,y)删除从x开始y个数
to_string()整数转为字符串
back()获取最后一个字符
reverse(x,y)翻转，左闭右开
#include<cstring>
memset(a,x,z)x为0/-1才有意义，若为char类型任何字符都可以，a是被初始化数组，z为字节数量
#include<new>动态分配内存
#include<memory>智能指针，内存工具
数据结构根据名称导入头文件即可
```