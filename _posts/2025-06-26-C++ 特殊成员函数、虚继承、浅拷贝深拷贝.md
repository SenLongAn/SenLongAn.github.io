---
title: C++ 特殊成员函数、虚继承、浅拷贝深拷贝
date: 2025-06-26 12:00:00 +0800
categories: [C++]
tags: []
math: true
---

# 特殊成员函数

## 架构

![alt text](/assets/img/blog/c++/成员函数架构.png)

类成员函数分为特殊成员函数、普通成员函数，特殊成员函数包括默认……函数、自定义……函数，默认……函数包括合成默认……函数、自定义默认……函数

类定义中的类成员均属于声明而非定义，定义是发生在类对象创建时

当一个函数只有声明没有定义，不允许被调用

合成：编译器自动生成（即生成public inline函数）

默认：特殊成员函数的最基本形式

### 构造

* 默认构造函数：可以不用实参进行调用的构造函数，包括没有显示形参列表 / 提供默认实参的构造函数，之所以强调显示是因为，编译器总是会为构造函数形参列表插入一个隐含的this指针
* 能否重载：能
* 能否声明为虚函数：构造函数不能声明为虚函数
  * 构造函数声明为虚函数会产生虚表，虚表指针，虚构造函数存放在虚表中，需通过虚表指针访问
  * 虚表指针在构造函数内初始化，即指向虚表
  * 因此虚构造函数无法访问
* 合成默认构造函数的合成条件：
  * 当没有自定义构造函数时，且需要触发以下条件：
    * 含有类对象数据成员，且该类对象有默认构造函数
    * 类派生自一个含有默认构造函数的基类时
    * 类包含虚函数：本身定义的 / 继承重写的
    * 带有虚继承的类

```c++
derived d;
derived* d = new derived;
base* b = new derived;
```

* 构造函数调用时机：定义类对象时自动调用
* 默认构造函数调用时机：定义类对象时没有显示初始化（即使用默认初始化方式）
* 合成默认构造函数的合成时机： 构造函数需要被调用的时候才会开始合成

  ```c++
  //自定义默认构造函数
  MyClass() : a(1), b(2)……{//成员初始化列表
      c = 3;//函数体赋值
  }
  ```

* **类成员初始化方式**：
  * **注：**
    * _以下为VS\_Debug模式下测试结果，对于诸如对类成员的默认初始化的方式、未满足合成条件的行为、未定义的值……受到编译器、调试模式、项目设置……影响，因此以下结果只作为参考_
  * 定义类对象
  * 按照类定义中的声明顺序，为所有类成员分配内存空间
  * 如果使用直接初始化方式定义的（有实参列表）
    * 如果有匹配的自定义构造函数
      * **成员初始化列表初始化**
        * 如果在列表中，内置变量支持3种显示初始化方式、类成员对象支持3种显示初始化方式
        * 如果未在列表中，如果存在**类内初始值**（成员初始化器），使用它，
        * 否则**默认初始化**：
          * 如果类对象是静态生命周期，成员：内置变量初始0、指针初始nullptr、指针堆内存未定义、类类型成员对象调用默认构造函数（类成员的类成员也同样遵守此类规则）
          * 如果类对象是自动/动态生命周期，成员：内置变量未定义、指针初始未定义、指针堆内存未定义、类类型成员对象调用默认构造函数
      * 调用构造函数体
        * **函数体内赋值**：如果有赋值操作，进行赋值
        * 其他操作指令……
    * 否则如果没有匹配的自定义构造函数，发生错误
  * 如果使用默认初始化方式定义的（无实参列表）
    * 如果有自定义的默认构造函数
      * 同上、
    * 否则如果没有自定义的默认构造函数
      * 如果有=default, 如果有类内初始值使用，否则使用默认初始化
      * 否则如果合成条件成立，合成默认构造函数，如果有类内初始值使用，否则使用默认初始化
      * 否则合成条件失败，如果有类内初始值使用，否则使用默认初始化，如果为自动生命周期，触发可继续的断言
* 哪些成员必须通过成员初始化列表进行初始化：
  * 常量成员变量，虽然允许类内初始值，但C++语法要求必须通过成员初始化列表进行初始化，默认初始化会产生未定值/0，由于不能被赋值，也就不能在函数体内赋值
  * 引用类型成员变量，同上
  * 没有默认构造函数即不满足合成条件的类类型成员, 应显示调用有参构造函数，
  * 继承体系中基类构造函数
* 成员变量的初始化顺序：与它们在类定义中的声明顺序相同，而不是它们在初始化列表中出现的顺序
* **静态变量**不能出现在列表中，因为它不属于具体类对象，它必须在类外显示定义和初始化
* 继承体系中基类构造函数调用方式
  * 不能在其他地方调用：基类构造函数仅能在派生类初始化列表中调用，我们也不能直接初始化基类的成员
  * 必须显示/隐式调用：派生类必须 显示的在其初始化列表中调用基类的构造函数 / 隐式调用基类的默认构造函数，如果基类没有构造函数，将编译失败，
  * 只有调用了基类的构造函数，才能初始化基类部分
* 继承体系中构造函数调用顺序是递归的
  * 调用顺序：派生类 -> 直接基类 -> 间接基类
  * 执行顺序：间接基类 -> 直接基类 -> 派生类

### 析构

```c++
~ MyClass();
```

* 析构函数合成条件：
  * 当未自定义析构函数时：
    * 且基类和成员变量均有可访问的析构函数
* 能否重载：不能像构造函数一样重载，一个类仅有一个析构函数，并且仅能使用默认版本，但可以自定义实现
* 能否声明为虚函数：析构函数可以声明为虚函数，特别是在继承体系中，析构函数最好声明为虚函数
* 析构函数调用时机：作用域结束/调用delete清理内存时
* 合成的默认析构函数做了什么：会对类内类类型成员按照声明逆序调用各自的析构函数，内置类型成员无需额外操作
* 继承体系中析构顺序根据定义方式决定：
  * 类对象非指针定义方式，无论是否是虚析构，都仅会调用自身的析构，因为它永远不会满足动态绑定条件
  * base* b = new base()，无论是否是虚析构，都仅会调用base的析构，因为指针对象类型和实际对象类型一致
  * base* b = new derived()
    * 调用delete时
      * 如果非虚析构，不满足动态绑定，仅会调用指针对象类型的析构函数
      * 如果是虚析构，满足动态绑定，会调用实际对象类型的析构函数，由于派生类析构隐式包含基类部分，因此完整的析构链会被调用
      * 执行顺序：派生类 -> 直接基类 -> 间接基类

### 拷贝构造

```c++
MyClass(const MyClass& class);
```

* 拷贝构造函数形式：首个为const（不希望对原对象做修改） / 非const 的同类类型引用，其余参数均有默认实参
* 能否重载：能，但有一定限制，const/非const版本，其余参数均有默认实参
* 能否声明为虚函数：不能
* 调用时机：使用拷贝初始化方式定义类对象
* 形参必须是引用：A = B 如果形参非引用类型而是值类型，在实参->形参传递过程中会发生拷贝，需要调用拷贝构造,即A的形参和B，A的形参的形参和B……无限递归调用
* 作用：将B类对象的所有成员值拷贝到A类对象中，以初始化A类对象，普通变量在 赋值，实参->形参，函数返回值 -> 隐式匿名 时发生数据拷贝，如果非拷贝而是移动形式就会导致原有的内存数据丢失，类类型变量和普通变量区别 就是包含大量内部数据，所以都应该遵守拷贝形式
* 合成的默认拷贝构造做了什么：将B类每个成员通过赋值方式（浅拷贝）传递给A类对应成员
* 合成的默认拷贝构造函数属于浅拷贝拷贝方式，因此如果类中包含指针成员，需要自定义深拷贝构造函数
* 继承体系中基类拷贝构造函数调用方式
  * 和普通的构造函数差不多，显示的在其初始化列表中调用基类的拷贝构造函数 / 隐式调用基类的默认拷贝构造函数，参数是派生类的实参（派生类可以转换为基类）
  * 只有调用了基类的拷贝构造函数，才能拷贝过来基类部分
* 继承体系中拷贝构造函数调用顺序
  * 调用顺序和普通的构造函数相同

### 拷贝赋值

```c++
MyClass& operator=(const MyClass& b){
  ……
  if(this != &b){//避免自赋值
    delete this->p;
    this->p = new type(*(b.p));
  }
	return *this;//返回左侧运算对象的引用
}
```

* 拷贝赋值函数：2元运算符，应该返回自身引用（可以支持连续赋值，否则如a=b=c这种形式，a=b返回右值作为左操作数将报错），是否加const都可以
* 能否重载：能，但有一定限制，const/非const版本，其余参数均有默认实参
* 能否声明为虚函数：不能，如果允许的话将仅会处理基类部分，派生类部分不会被处理，造成错误结果
* 调用时机：A已初始化,使用同类类型对象B赋值（=）时
* 作用：将B类对象的所有成员值拷贝到A类对象中，以将B类对象赋值给A类对象，内部实现和拷贝构造几乎无差异
* 合成的默认拷贝赋值做了什么：将B类每个成员通过赋值方式（浅拷贝）传递给A类对应成员
* 避免自赋值：
  * 提高效率
  * 如果类包含指针成员，调用delete将清理掉内存数据，丢失了数据，如果没有delete，分配了新内存，旧内存无法被释放，容易造成内存泄漏

### 移动构造



### 移动赋值

## 关键字

```c++
MyClass() = default;  // 等价于：MyClass();
MyClass(const MyClass&) = delete;
MyClass& operator=(const MyClass&) = delete;
```

private：

default：创建合成默认函数，相比于自定义默认函数，效率要高

delete：删除函数，可以对任何成员函数使用

override：

final：

# 虚继承

![alt text](/assets/img/blog/c++/菱形继承.png)

```c++
class X  { public: int i; };
class A : virtual public X{ public:int j; };
class B : virtual public X{ public:double d; };
class C : public A, public B{ public: int k; };
```

* 虚继承是一种特殊的继承机制，多重继承下确保子类对象中,每个父类只含有一个副本，即解决菱形继承问题
* 若类A虚继承于类X，则对于A来说，类X是类A的虚基类
* 虚继承会一直传递到最终派生类

# 浅拷贝与深拷贝

* 浅拷贝
  * 定义：对类对象中的成员进行简单的赋值
  * 问题：
    * 存在静态成员
      * 静态成员不会被拷贝，多个类对象共享同一静态成员
    * 存在动态成员
      * 由于默认赋值操作：A_p = B_p, 是将B_p指向的内存地址拷贝给A_p，因此它们共享同一内存，共同指向同一个对象
      * 如果两个指针都被释放掉，就会发生错误：同一个内存被释放了两次

* 深拷贝
  * 定义：对类对象中的成员非进行简单的赋值

  ```c++
  A_p = new type();//分配独立内存
  *A_p = *B_p;//值拷贝
  ```

  * 方式：手动new一个新内存，初始为B_p的值，将新内存给A_p