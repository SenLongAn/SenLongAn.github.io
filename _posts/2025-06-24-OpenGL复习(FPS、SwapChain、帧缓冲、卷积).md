---
title: OpenGL复习(FPS、SwapChain、帧缓冲、卷积)
date: 2025-06-24 12:00:00 +0800
categories: [OpenGL]
tags: []
math: true
---

## 屏幕刷新率， FPS，垂直同步VSync

![alt text](/assets/img/blog/Graphic/刷新率_交换链_FPS.png)

* 屏幕刷新率：每秒显示器更新画面的次数，单位HZ，每次刷新时从swapchain的fontbuffer逐行扫描读取
* 帧率FPS/渲染速率：每秒渲染的图像次数，写入到swapchain
* 垂直同步（VSync）：强制在显示器刷新完成后再交换缓冲区
* 问题
  * 屏幕刷新率由逐行扫描速度决定吗
    * 可以这样说，但准确来说应该是显卡硬件，驱动……决定上限，可以由用户显示设置具体值……
  * 帧率由什么决定
    * 显卡硬件，驱动，内存，代码复杂度……
  * 一般来说屏幕刷新率 vs. FPS 谁更快
    * 有时帧率 > 屏幕刷新率，有时帧率 < 屏幕刷新率
  * 画面撕裂是什么
    * 在读取过程中，并非读取同一组数据，出现的画面割裂现象
  * 逐行扫描会造成画面撕裂，屏幕本身像素有旧的颜色值，在逐行扫描过程中新的像素逐渐填充，会画面撕裂
    * 确实，但实际上过程非常快，并不会看到明显的画面撕裂
  * 为什么不能同时读写同一缓冲？？？
    * 数据出现异常

## 交换链

* 管理多个缓冲区，双缓冲区有两个缓冲，三缓冲区有三个缓冲，首个buffer作为screenbuffer/font buffer，其余buffer为back buffer
* 呈现/交换：渲染完成执行，首个backbuffer取代screenbuffer，screenbuffer取代末尾backbuffer
* 作用：
  * 假如只有一个缓冲，渲染（写入缓冲），扫描（读取缓冲）
    * 在一个缓冲同时读写
      * 帧率 > 屏幕刷新率，画面撕裂
      * 帧率 < 屏幕刷新率，卡顿，画面撕裂
    * 阻止在一个缓冲同时读写
      * 帧率 > 屏幕刷新率，扫描过程中渲染必须等待，在渲染过程中扫描也必须等待，浪费GPU算力
      * 帧率 < 屏幕刷新率，卡顿
  * 如果有两个缓冲
    * 在一个缓冲同时读写
      * 不会发生，每次读取的是font buffer，而它通过渲染完成后交换而来，是一张完整的缓冲
    * 阻止在一个缓冲同时读写
      * 帧率 > 屏幕刷新率，画面撕裂
      * 帧率 < 屏幕刷新率，卡顿，画面撕裂
    * VSync
      * 帧率 > 屏幕刷新率，浪费GPU算力，避免画面撕裂
      * 帧率 < 屏幕刷新率，卡顿，避免画面撕裂
  * 如果有三个缓冲
    * 通过额外的备用缓冲，降低卡顿概率，有更高的画面流畅度
* 问题
  * 交换链，场景和摄像机还没有进入n帧怎么渲染 N 帧
    * 理解有误，渲染完成后，再次根据最新的数据渲染到新的缓冲区
  * 多个渲染可以并行吗？
    * 理论可以，但不符合期望，我们希望交换链的缓冲按顺序存储更新的数据，如果支持并行渲染，会导致无序的结果，从而画面呈现颠倒乱序不符合期望，因此需要并发渲染，渲染完成后再渲染下一帧
  * 交换链缓冲区可以无限制吗
    * 不可以，消耗显存，
    * 研究发现三缓冲之后再增加缓冲效果变化不大

## 帧缓冲区

* 所有缓冲区的组合，每个缓冲区又称为附件，所有缓冲区的采样点数量都应该一致
* 离屏渲染：渲染到非默认帧缓冲（输出到屏幕）
* 纹理附件：可被读写，支持多种格式，可以在shader中采样
* 渲染缓冲对象附件：仅支持opengl的原生渲染格式，仅可写不可读，有更快的写入速度，通常在深度/模板缓冲不需要读取时使用
* 附件类型
  * 颜色
  * 深度
  * 模板
  * 深度模板
* 使用场景
  * 阴影贴图
  * 后期处理
  * 镜子高度反射物体
  * MRT
  * ……

## 卷积

* 核(Kernel)（或卷积矩阵(Convolution Matrix)），一个a行b列的矩阵，每个元素作为权重
* 对源纹理卷积过程，输出新纹理：对每个像素，以自身为中心取a行b列的像素区域，每个像素和卷积核的对应权重相乘，再相加，更新这个像素的结果