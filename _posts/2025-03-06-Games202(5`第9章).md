---
title: Games202(5·第9章)
date: 2025-03-06 12:00:00 +0800
categories: [Games202]
tags: [实时渲染]     # TAG names should always be lowercase
math: true
---
# 第9章

#### Screen Space Directional Occlusion (SSDO)屏幕空间定向遮挡

**DO**

在AO中，我们假设每个p点受到的环境光都是常数，虽然AO效果更强烈，但是只是简单的让遮蔽位置整体暗一点，而不能颜色混合（现实世界中环境光是有颜色的）

DO利用了ray tracing思想，向周围发射光线，和AO相反的是，AO的 RT思想是未击打的部分可以接受间接光照，击打的部分表示被遮挡，这和DO是刚好相反的

其中DO未击打部分计算直接光照，击打部分计算被击打Q点的直接光照对p点的radiance贡献

现实的情况是AO和DO的混合，所以它们并没有矛盾

**Rendering Equation分解简化**

对于次级光源是哪些点，仍然用之前的做法RSM，对于渲染方程我们会将没有遮蔽的部分与遮蔽的部分分开考虑，我们只关心V == 0 的部分，因为这些点提供间接光照，但如何求得哪些patch的V == 0呢？

我们需要知道哪些次级光源对p有贡献，与AO一样的是在半球区域撒点，在屏幕空间也就是camera方向看patch的V，但是V项判定是反的，如果x点比摄像机SM中pixel的depth值大，则x点提供间接光照

**问题**

![1741272814251](/assets/img/blog/Games202/SSDO的问题.png)

和AO一样由于都是在屏幕空间，仍然会出现判断错误，例如A点，我们判断为V == 0，但实际上它的patch是没有遮挡的

#### Screen Space Reflection (SSR)屏幕空间反射

#### IBL . PRT . RSM . LPV . VXGI . SSAO . SSDO . SSR总结

_它们都是实时渲染中实现GI的方法_

IBL:

* 对场景渲染一张环境贴图，以cubemap/sh存储
* 将rendering equation分解简化，以便预计算L，F，Max……项

PRT:

* 对场景渲染一张环境贴图，以cubemap/sh存储
* 将rendering equation分解为入射光和传输函数两部分，
* **预计算**L，F，V，Max……项，并利用基函数存储，在运行时只需要简单的线性组合，就可以计算出p点的GI值

RSM:

* 对每个光源渲染一张**反射阴影贴图**RSM，pixel存储深度，世界坐标，法线等信息，每个pixel对应的世界网格作为次级光源 ，
* 对每个p点，投影到RSM中，从RSM中取临近像素对应的次级光源 * 权重 ，并求累加和作为p点的GI值
 
LPV:

* 把3D场景划分**体素**，利用空间数据结构
* 利用SM找到次级光源，并注入到体素内（一个体素可能包括多个光源），
* 遍历体素内所有次级光源，从中心的6方向(上下左右前后)，传播radiance，接收到radiance的各自用2阶的sh表示，
* 对于p点找到所在的体素，获得体素存储的所有radiance,即p点的GI值

VXGI

* 把3D场景划分体素，利用空间数据结构
* 利用SM找到次级光源，并注入到体素内，还包括输入方向和法线范围两个信息，根据材质准确算出出射方向
* 对于p点是根据**camera ray**找到的，因此知道入射方向，根据p点的表面**材质**
  * Glossy，向反射方向追踪出一个锥形(cone)区域，对体素层级查询，找到所有与锥形相交的体素，通过体素的2个信息计算的radiance得到p点GI
  * diffuse，考虑若干cone

SSAO

* 根据已知假设对rendering equation分解简化，
* 自定义环境光  * （乘以）
* 以p点的法向半球内撒点作为遮挡/未遮挡因子 * 权重 计算V项

SSDO

* 根据RSM求得次级光源的贡献值 * （乘以）
* 以p点的法向半球内撒点作为遮挡/未遮挡（和AO相反）因子 * 权重 计算V项

SSR

