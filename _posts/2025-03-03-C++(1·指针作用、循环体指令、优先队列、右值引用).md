---
title: C++(1·指针作用、循环体指令、优先队列、右值引用)
date: 2025-03-03 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---
### 为什么使用指针？

* 高效传递对象（数据结构/函数参数……，使用指针，可以避免拷贝，提高性能）
* 实现多态和动态绑定（在继承体系中，根据传递派生对象到基类指针，从而调用派生类函数）
* 动态分配内存，比如用户数据大小不确定，必须使用对数组的指针才能为数组动态分配内存
* 实现数据结构和算法（链表，树，图：允许高效插入、删除和调整节点）

但是需要手动分配释放内存,否则没有delete会造成内存泄漏

智能指针防止忘记delete的情况，会自动delete


### break . continue

break: 退出本次循环，继续循环外的指令

continue: 跳过本次循环体中剩余的语句，继续执行下一次循环的循环体

### priority_queue

**定义：**

优先队列也称为堆heap，堆的本质是完全二叉树（从上到下、从左到右，依次填充）（包含在完全树类中的一种特殊的tree）

**索引：**

* 父节点索引i：左孩子:2 * i + 1, 右孩子:2 * i + 2
* 左/右节点：父节点：(i-1)/2
* 通常用数组实现

**堆排序算法：**

堆排序算法，c++提供了两个可选的比较函数：less对应大顶堆（默认）（父>子）（堆顶最大），greater小顶堆（父<子）（堆顶最小），和正常认知是相反的，这是和它的底层实现有关

大顶堆：当插入新的节点x时， 父节点 < x 会交换

```c++

void HeapAdjust(int* arr, int start, int end)//将从以start开始到end区间调整为大根堆
{
	int tmp = arr[start];//初始为根节点
	//从根节点的左节点开始，每次继续向被交换位置（因为只有被交换的子树部分，元素顺序才可能错误）的左指针搜索
	for (int i = 2 * start + 1; i <= end; i = i * 2 + 1)//自顶向下
	{
		if (i < end && arr[i] < arr[i + 1])//找到i的左右孩子最大值
		{
			i++;
		}
        //底层元素提升：如果指向的孩子>初始根节点的值
		if (arr[i] > tmp)
		{
			arr[start] = arr[i];//更新start指向的值为i的值
			start = i;//让start指针移动到i
		}
        //本次i不必被更新
		else
		{
			break;
		}
	}
	arr[start] = tmp;//让start指向的值为最初根节点的值
}
void HeapSort(int* arr, int len)//堆排序
{
	//初次构造大顶堆
	//从最后一个非叶节点（i - 1）/ 2 ->((len-1)-1)/2开始到len - 1最后索引结束的区间，每次找或左或父的节点i--，直到根节点0为止
	for(int i=(len-1-1)/2;i>=0;i--)//自底向上
	{
		HeapAdjust(arr, i, len - 1);
	}
	//排序
	int tmp;//temp变量
	for (int i = 0; i < len - 1; i++)//index--
	{
		tmp = arr[0];//根节点的值
		arr[0] = arr[len - 1-i];//index的值 
		arr[len - 1 - i] = tmp;//index更新为根节点的值
		HeapAdjust(arr, 0, len - 1-i- 1);//对剩余部分构建大顶堆
	}
}
```
* 初始化：将无序序列，从上到下、从左到右，依次填充到完全二叉树中，用数组表示不用这部操作
* 初次构造大顶堆：
  * 从最后一个非叶节点开始，比较它的左右节点中最大的一个的值，如果大就交换位置，也就是如果父 < max(left, right)就交换
  * 每次调整时，对于被调整下来的父节点，都会做上述操作，直到作为了叶节点 / 孩子都比它小
  * 结束后所有父 > 子
* 排序：根节点和index（从最后一个开始）节点交换，剩余元素重新构建大顶堆，每次index--，循环这个步骤，直到index == 0

### 左值，右值，左值引用，右值引用

**定义**

* 左值是对象，有内存地址，有变量名，有值，表达式结束后不会被销毁
* 右值是临时对象，无内存地址，无变量名，有值，表达式结束后会销毁

* 非常量左值：形如 ： 数据类型 + 变量名;
* 常量左值：形如 ： const + 数据类型 + 变量名;
* 非常量右值：形如 ： 数据类型 + 变量名 = x; //这里的x
* 常量右值：形如 ： int a,b; (a + b); //这里的 a + b

* 对非常量的左值引用：可以绑定 左值
* 对常量的左值引用：可以绑定 非常量左值、常量左值、非常量右值、常量右值
* 对非常量的右值引用：可以绑定 非常量右值
* 对常量的右值引用：可以绑定 非常量右值、常量右值

对于常量左值引用可以绑定到右值上，但右值引用不能绑定任何类型的左值，c++的API：std::move()可以将左值强制转换为右值，从而 左值可以被右值引用绑定

**右值引用作用：**

```c++
//移动构造
MyString(MyString&& str) { 
    _len = str._len; 
    _data = str._data; 
    str._len = 0; 
    str._data = NULL;   // ! 防止在析构函数中将内存释放掉
}
//移动赋值
MyString& operator=(MyString&& str) { 
    if (this != &str) { 
        _len = str._len; 
        _data = str._data; 
        str._len = 0; 
        str._data = NULL;  // ! 防止在析构函数中将内存释放掉
    } 
    return *this; 
}
```

* **转移语义**：当用一个对象初始化另一个对象 / 为另一个对象赋值时，需要将对象内存的数据拷贝到新内存中， 但是当我们并非关心原对象（把作为临时对象）时，我们使用右值引用，将会直接将 临时对象内存的数据移动到新内存中，然后释放临时对象内存，这样仅仅发生**转移数据而非拷贝数据**，减少了内存并增加了运行效率
* 注意：当创建一个对象a被右值引用绑定，把a中数据转移给对象b时，由于a被作为了临时对象，在销毁之后（比如作为函数形参调用完函数后将不再存在）会被立即析构，释放掉绑定的内存，那样b获得的这块内存中的数据就不存在了，因此，我们应在使用后，将右值引用的数据指针**指向空**，防止清理掉内存数据

```c++
template<typename T>
void forwardPrint(T&& arg) {
    print(std::forward<T>(arg));
}
```
* **完美转发**：当我们编写一个函数模板确保这些参数的原始属性（左值或右值）能够被正确传递
  * 引用折叠：T& & 折叠为 T& ，T& && 折叠为 T& ，T&& & 折叠为 T& ，T&& && 折叠为 T&& ， 使用万能引用（T&&）作为函数模板的参数时，编译器会根据传入的实参是左值还是右值来推导 T 的类型
  *  std::forward依赖于引用折叠规则，根据模板参数 T 的推导结果，将参数转换为合适的左值或右值引用
* 含有不能共享资源的类对象：像IO、unique_ptr……






