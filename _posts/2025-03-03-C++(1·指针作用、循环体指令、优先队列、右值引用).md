---
title: C++(1·内置指针、数组、循环体指令、右值引用)
date: 2025-03-03 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---
### 内置指针

* 指针本质：通过间接指向和操作内存，提供了更灵活的操作能力

* 指针作用在许多c++特性中使用指针间接操作内存 相比直接操作内存 有更多的优势
  * 作为函数参数返回值、数组和指针的转换时，指针类型元素的数组（虚表），仅传递/存储地址而非整块内存，高效传递对象/减少内存的使用
  * 非指针无法访问派生类内存，只能静态绑定，基类指针可以指向基类也可以指向派生类，动态访问实际类型内存->虚指针->虚表->虚函数地址，从而实现多态的动态绑定
  * 使用函数指针实现回调函数，可以接受不同的函数地址，有更高的灵活性

    ```c++
    class A {
        A a;//❌ 错误: 类的定义中不能直接包含同类对象，递归下去，编译器无法计算出 A 类的大小
        A* a;//✅ 正确
        A& a;//✅ 正确
    };
    ```

  * 在实现链式数据结构时通常需要next（链表，树，图），如果next为类类型成员，内存分配无限循环，不被允许，如果next为类类型指针成员，内存分配有限，被允许
  * 动态生命周期管理，指向不同的内存，灵活性较高
* 1级指针，2级指针：type** 指针的指针
* 复杂指针阅读
  * 右左法则：从标识符开始，先向右看，然后向左看，每当遇到圆括号时，就调转阅读方向，当括号内的内容解析完毕，就跳出这个括号，重复这个过程直到表达式解析完毕

    ```c++
    int i;//从i开始，右侧没有看左侧，则i是int类型
    int *a[3];//从a开始，右侧说明a是包含3个元素的数组，左侧说明每个元素是int*类型
    int (*a)[3];//从a开始，右侧是括号，左侧说明a是指针，左侧遇到括号，右侧说明a指向包含3个元素的数组，左侧表明每个元素是int类型
    int **p;//p是指针，指向的对象类型也是指针（二级指针），此指针指向的类型是int
    int *foo();//从foo开始，右侧说明foo是函数，左侧说明返回类型是int*
    int (*foo)();//从foo开始,右侧是括号，左侧说明foo是指针，左侧遇到括号，右侧说明foo指向函数（函数指针），左侧说明返回类型是int
    int (*(*vtable)[])();//vtable是指针，指向数组，每个元素是指针类型，指向函数（函数指针），左侧说明此元素返回类型是int
    int *(*p(int))[3];//p是包含int类型参数的函数，返回类型为指针，此指针指向包含3个元素的数组，每个元素类型是指针，指向int类型对象
    int (*(*p)(int))(int);//p是指针，指向包含int类型参数的函数，函数返回类型为指针，指针指向包含int类型参数的函数，函数返回类型为int
    ```

  * int   p;
    * 从p开始向右看，没有，向左看，p是int类型的变量
  * int   *p;
    * 从p开始向右看，没有，向左看，p是指针，再向左看，p指向int类型元素
  * int   *p[3];
    * 从p开始向右看，p是有3个元素的数组，向左看，元素类型为int*
  * int   (*p)[3];
    * 从p开始向右看，遇到圆括号时，向左看，p是指针，跳出括号，先向右看，p指向有3个元素的数组，向左看，元素类型为int
  * int   **p;
    * 从p开始向右看，没有，向左看，p是指针，向左看，p指向int*
  * int   p(int);
    * 从p开始向右看，p是参数为int类型的函数，向左看，函数返回类型为int
  * int   (*p)(int);
    * 从p开始向右看，遇到圆括号时，向左看，p是指针，跳出括号，先向右看，p指向参数为int类型的函数，向左看，函数返回类型为int
  * int   *(*p(int))[3];
    *  从p开始向右看，p是参数为int类型的函数，向左看，函数返回类型为指针，跳出括号，先向右看，函数返回的指针指向有3个元素的数组，向左看，元素类型为int*
  * int   (*(*p)(int))(int);
    * 从p开始向右看，遇到圆括号时，向左看，p是指针，跳出括号，先向右看，p指向参数为int类型的函数，函数返回类型为指针，跳出括号，先向右看，函数返回的指针 指向参数为int类型的函数，函数返回值为int
* 函数指针
  * 定义函数指针：return_type (*p) (parameter_list);
  * 函数指针数组：return_type (*p[n]) (parameter_list)
  * 函数指针数组的指针:return_type (*(*p)[n]) (parameter_list)
  * 初始化/赋值： = &func_name  <==>  = func_name
  * 调用函数：(*p)(parameter_list) <==> p(parameter_list)
  * typedef
    * 使用 typedef 定义函数指针，代码看起来更简洁，也更不容易出错, 并且函数指针作为函数返回值，必须使用typedef声明的类型
    * 声明函数类型: typedef return_type (type_func)(parameter_list);
    * 声明函数指针类型: typedef return_type (*type_p)(parameter_list);
    * 定义函数指针：
      * type_func* p;
      * type_p p;
    * 调用：p(parameter_list);

### 数组
* 数组是用于储存多个相同类型数据的集合
* 数组之间不能直接赋值，只能一个一个元素的赋值
* 数组在内存中是连续的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的
* 对于数组获取元素个数：sizeof（数组名）/sizeof（元素类型），总字节/元素字节数

  ```c++
  //静态数组
  int arr[5];
  int arr[5] = {1, 2, 3, 4, 5};
  int arr[5] = {};
  int arr[2][3]; 
  int static2DArr2[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
  };

  //动态数组
  //一维数组：
  int* arr = new int[n];//创建一维数组
  delete[] arr;//销毁

  //二维数组：（原生数组arr[row][col]内存固定， 而以下是运行时动态分配的）
  int** arr = new int*[row];//指向数组的指针，有row行
  for(int i=0;i<row;i++)
  {
    arr[i] = new int[col];//每个元素是一行的col列
  }
  //释放
  for(int i=0;i<row;i++)
  {
    delete[] arr[i];//释放所有元素
  }
  delete[] arr;
  ```

* 初始化静态数组和动态数组
* C风格字符串
  * const char* str = "abc"; 
    * C风格字符串 -> 数组const char[] -> 指针const char*
  * char a[3] = "aaa"; char* arr = a; 
    * C风格字符串作为赋值的右侧时：C风格字符串(字面值/常量左值，存储在常量区，在整个程序运行期间一直存在) 赋值（值拷贝）给数组元素，由于数组非底层const，可以用非常量指针指向它并修改数组元素值
* 数组和指针的转换
  
  ```c++
  //一维传参：//这些参数完全等价，编译器都会将其视为指针 type *
  void func(type arr[]) / void func(type arr[n]) / void func(type *arr) 
  //二维传参：
  void func(type arr[x][y]) / void func(type arr[][y]) / void func(type (*arr)[y]) 
  //数组赋值给指针
  type a[]; 
  type* arr = a;
  ```

  * 数组作为参数 / 赋值给指针时，实参数组会自动退化为首个元素的地址
  * 作用：
    * 避免栈溢出
    * 与 C 语言兼容
  * 退化影响：无法通过 sizeof(arr) 获取数组真实大小
    * 解决方式：
      * 额外传递长度参数
      * type (&arr)[n]通过引用传递数组

### 动态分配内存的作用
  * 静态生命周期对象一直占用内存，造成内存浪费，在不需要时手动释放内存，避免内存浪费
  * 自动生命周期对象通常情况下栈区，栈区的大小容不下过于庞大的数据，所以在堆分配内存

### break . continue

break: 退出本次循环，继续循环外的指令

continue: 跳过本次循环体中剩余的语句，继续执行下一次循环的循环体

### 左值，右值，左值引用，右值引用

* 左值：
  * 特点：可寻址的内存、表达式结束不会立即销毁、可以修改值，有符号名，可以作为赋值运算符的左右操作数，可以作为递增减运算符的操作数
  * 常见形式：变量，赋值、前置递增递减表达式返回值，条件运算符两个表达式都是左值……
  * const左值：被const修饰的非常量左值
  * 常见形式：字符串字面值（const左值），被const修饰的变量
  * 引用是别名，不是对象，但可以像左值一样使用
* 右值：
  * 特点：不可寻址的内存、表达式结束立即销毁、不可修改值，没有符号名，仅能作为赋值运算符的右操作数，不能作为递增减运算符的操作数
  * 常见形式：变量作为赋值运算符的右操作数创建内置右值，在除了字符串的其他字面值，表达式求值过程中创建的临时对象：算术、逻辑、关系、位运算、后置递增递减表达式返回值，条件运算符两个表达式都是右值，函数非引用返回值……
  * 纯右值：表达式结束立即销毁
  * 将亡值：通过std::move转换后的右值，表达式结束不会立即销毁，可以寻址
  * const右值：纯右值本身就是常量，它不可被赋值，将亡值可以是非常量，move转换给非常量
* 左值引用：
  * type & name = val;
  * 定义时必须初始化，否则编译错误
  * 可以赋值，但更改的是绑定对象的值，而非绑定另一个对象
  * 引用类型和绑定对象类型要严格匹配
  * 可以被左值引用绑定的？非常量左值
  * 引用的底层是指针，汇编中步骤是一样的

  ![alt text](/assets/img/blog/c++/左值右值引用.png)

  * 左值引用**直接**绑定现有对象
  * 左值引用是左值,可以获取左值引用的地址
  * 左值引用是左值，但不是对象
  * 函数返回值
    * 函数非引用返回值是右值
    * 函数引用返回值是左值/引用
    * 函数对常量的引用返回值是const左值，但不能出现在赋值运算符的左侧
  * 左值引用作用：
    * 避免现有对象拷贝，节省内存开销
    * 函数引用形参，直接操作传入的对象而非副本
    * 函数引用形参，实现多返回值
    * 函数引用返回值，实现链式调用
* 对const的左值引用
  * 不能通过该引用修改所绑定对象的值
  * 引用类型和绑定对象类型允许隐式类型转换
  * 可以被对const的左值引用绑定的？常量左值，非常量左值，纯右值，将亡值
  * 对const的左值引用绑定右值时，**延长**右值的生命周期，右值随着引用销毁后销毁（直接引用的右值，右值不可修改，也不能通过引用修改）
* 右值引用：
  * type && name = val;
  * 定义时必须初始化，否则编译错误
  * 可以赋值，但更改的是绑定对象的值，而非绑定另一个对象
  * 可以被右值引用绑定的？
    * 纯右值
    * 将亡值
      * std::move()
        * 左值强制转化为将亡值，当初始化/赋值给其他对象时，左值的资源**转移**到右值引用的地址，资源随着引用销毁后销毁

  ![alt text](/assets/img/blog/c++/左值右值引用2.png)

  * 右值引用绑定纯右值后，将临时资源**转移**到右值引用的地址，资源随着引用销毁后销毁（相当于引用左值，左值可修改，可通过引用修改）
  * 右值引用是左值,可以获取右值引用的地址
  * 右值引用是左值，但不是对象
  * 作用：
    * 相比于对const的左值引用，右值引用可以避免拷贝临时资源的同时，允许对右值操作
    * 移动语义：对于不再需要的对象直接将资源移动到另一个对象，而非拷贝，节省内存开销
      * 使用场景：

        ```c++
        A(const A& other) 
        {
          data = new char[strlen(other.data) + 1];//分配新空间
          strcpy(data, other.data);//资源拷贝
        }
        A(A&& other) 
        {
          data = other.data;//资源转移
          other.data = nullptr;//释放旧对象
        }
        ```
        
        * 移动构造

        ```c++
        class A{
          A& operator = (A & other){
            if (this != &other) {// 避免自赋值
              data = new char[strlen(other.data) + 1];
              strcpy(data, other.data)
            }
            return *this;
          }
          A& operator = (A && other){
            if (this != &other) {  
              delete[] data;// 释放当前对象的资源
              data = other.data;
              other.data = nullptr;
            }
            return *this;
          }
        }
        ```
        
        * 移动赋值
    * 完美转发：将函数的参数以左值或右值的形式完美转发给另一个函数
      
      ```c++
      void process(int& i) {
          std::cout << "处理左值: " << i << std::endl;
      }

      void process(int&& i) {
          std::cout << "处理右值: " << i << std::endl;
      }
      template<typename T>
      void logAndProcess(T&& param) {
          process(std::forward<T>(param));
      }
      ``` 
      
      * 引用折叠
        * 规则：（模板类型、实参是否有引用）
          * T& -> & == &
          * T&& -> & == &
          * T& -> && == &
          * T&& -> && == &&
        * 触发条件：
          * 模板实例化
          * 自动类型推导，包括auto关键字和decltype
        * 作用：
          * 确保组合不会得到引用的引用（不合法）
      * 万能引用
        * T&& 可以绑定到左值或右值，并保证值类别
      * std::forward\<T>(param)：保持param的原始值类别（左值/右值）
      * 作用：编写既能接受左值、又能接受右值参数的模板代码
* 对const的右值引用
  * 不能通过该引用修改所绑定对象的值
  * 可以被对const的右值引用绑定的？纯右值，将亡值
  * 它和对const的左值引用作用一样，并且对const的左值引用可接受的值类型广泛，所以一般不会使用

**std::ref() std cref()** 

* 引用包装器std::ref能使用reference_wrapper包装代替原本会被识别的值类型，防止拷贝，但它不能使被包装的对象变成引用
* 对于万能引用，虽然模板参数会推导为引用类型，但是参数仍然会发生拷贝（即使实参是引用类型）
* 比如bind / thread ，如果关联的函数带有引用的形参，我们应该向万能引用参数传递引用，需要用ref / cref 包装

### 模板参数类型推断

```c++
template<typename T>//模板参数类型
void f(ParamType param);//函数参数类型
f(expr);//实参
```

在编译阶段使用expr来推断ParamType和T这两个类型

1. ParamType 是一个指针或者引用
    1. 忽略expr与ParamType共有的部分，expr剩余的部分作为T
2. ParamType 是右值引用
   1. expr的类型为左值，T为expr的类型 + 左值引用，根据引用折叠规则，确定ParamType的类型, 也是左值引用
   2. 忽略expr与ParamType共有的部分，expr剩余的部分作为T，不会引用折叠，ParamType的类型也是右值引用
3. ParamType 是普通变量
   1. T为expr忽略 引用，const，volatile…，剩余的部分作为T
4. expr 是数组
   1. T为 const type *