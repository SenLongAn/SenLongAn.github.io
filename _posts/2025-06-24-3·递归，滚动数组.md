---
title: 3·递归，滚动数组
date: 2025-06-24 12:00:00 +0800
categories: [算法与数据结构]
tags: []
math: true
---

## 递归

* 思想：将问题分解为同类的子问题而解决问题的方法
* 定义：函数调用自身的过程
* 方向：自顶向下调用，自底向上执行（由底的子问题合成顶的父问题），从子问题开始计算

```c++

int func(intn){//函数功能：返回n的阶乘
  //结束条件
  if(n <0)return-1;
  if(n ==0|| n ==1 )return n;
  //等价关系式
  return n *func(n -1);
}
```

* 阶乘：n! = 1……n的乘积
* 递归步骤：

  * 明确函数功能
  * 状态转移方程：分解问题，找出函数的等价关系式，调用自身
  * 返回条件（即不能分解的基本问题）
* 优点：对于某些问题递归要比循环简单许多
* 缺点：存在函数调用的开销，子问题被大量重复调用，容易栈溢出，通常比迭代更低效
* 使用场景：

## 滚动数组

```c++

//循环

intfunc(intn){
  intd[n];
  d[0] =0;
  d[1] =1;
  for(int i =2; i <= n; i++){
    d[n] =d[n -1] +d[n -2];
  }
  returnd[n];
}
//滚动数组
intfunc(intn ){
  intd[3];
  d[1] =0;
  d[2] =1;
  for(int i =2; i <= n; i++){
    d[0] =d[1];
    d[1] =d[2];
    d[2] =d[0] +d[1];
  }
  returnd[n];
}
```

* 斐波那契数列：F (0)=0，F (1)=1, F (n)=F (n - 1)+F (n - 2)（n ≥ 2）
* 步骤

  * 创建大小为3的数组
  * 填充后2个元素值
  * 交换值填充
* 优点：节约空间，如果用它代替递归还可以节省时间
* 缺点：
* 使用场景：每次只依赖前两个元素

## 备忘录

* 优点：通过将子问题计算结果保存，以防止子问题重复调用计算, 是递归的优化
* 数据结构：通常使用关联容器

## 动态规划DP

* 思想：将问题分解为同类的子问题而解决问题的方法
* 优点：相比于递归减少函数调用的开销，通过将子问题计算结果保存，以防止子问题重复调用计算，是递归的优化
* 方向：自底向上，从子问题开始计算
* 步骤：
  * 明确函数功能
  * 状态转移方程
  * 明确dp数组元素的功能：存储了所有的子问题
  * 设置dp基本情况
  * 循环填充dp元素
* 一维动态规划：