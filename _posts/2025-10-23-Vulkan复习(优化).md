---
title: Vulkan复习(优化、绘制矩形)
date: 2025-10-23 12:00:00 +0800
categories: [Vulkan]
tags: []     # TAG names should always be lowercase
math: true
---

# VkCommandBuffer数组

* acquire（请求图像）->record（录制命令）->submit（执行命令和渲染）->present（交换链交换，并被显示器读取）
* 只有一个VkCommandBuffer时：
  * 第i+1帧acquire会正确请求到图像吗，假设上一帧的present没有执行完，行为是：等待 / 获取frontbuffer / 获取backbuffer？
    * 会等待present中交换操作完成后（frontbuffer 始终被显示器占用，我们无法获取它），而不必等待读取完成，就可以获取到新的backbuffer，在UINT64_MAX时间内会一直等待，阻塞CPU线程
  * record和 acquire和submit有同步机制吗，怎么保证record在acquire后submit前执行？
    * 有隐式同步机制，
    * acquire的等待会阻塞整个CPU线程，包括后续的record操作,
    * record是CPU命令，可以保证内部顺序，
    * 在它们执行完成后执行vkQueueSubmit，
    * acquire和submit都是GPU命令（单commondbuffer其实可以不用semaphore），无法自动保证内部执行顺序，手动用semaphore保证顺序
  * 流程：当第i帧的submit结束就可以第i+1帧的流程执行，需要等待acquire后（也就是上一帧的present后），然后record执行，submit执行
  * 下一帧的流程需要等待上一帧的完成
* VkCommandBuffer数组时：
  * 第i+1帧acquire会正确请求到图像吗？同上
  * 和单VkCommandBuffer的区别？双缓冲下本质没有区别，虽然vkWaitForFences不会阻塞第i+1帧的执行，但vkAcquireNextImageKHR会阻塞第i+1帧的执行（因为i帧的present中交换操作没有完成，同上面一样还是需要交换完成后才能i+1帧的流程），因此本质没有改变
  * 真正可以让 CPU 与 GPU 并行是需要三缓冲实现的
* 流程：VkCommandBuffer、VkSemaphore、VkFence都变为数组，包括初始化，使用时使用frame id，每帧流程后都会对++frame id % max frame，清理数组

# 重建swapchain

* 当窗口大小改变时，窗口表面会发生变化，导致交换链大小不再与之兼容，因此要捕获此事件和重建swapchain
* 流程：
  * 初始化窗口：glfwSetFramebufferSizeCallback当窗口大小改变时，就会调用它的回调函数，glfwSetWindowUserPointer将参数2任意用户数据指针与参数1GLFW 窗口关联，通过glfwGetWindowUserPointer获取用户指针，在回调函数中，让bool开关打开
  * 清理SwapChain：将清理操作抽象出来到函数中，包括VkSwapchainKHR，VkImageView，VkFramebuffer
  * 重新创建SwapChain：清理并重建（先通过glfwGetFramebufferSize获取帧缓冲大小（单位是像素，物理大小，随窗口大小按比例改变），当宽高为0时，会等待窗口事件，不会渲染）
  * 每帧：在Acquire后和Present后，如果VK_ERROR_OUT_OF_DATE_KHR交换链已变得与表面不兼容，就重建SwapChain，并退出函数，由于窗口未关闭，因此会继续下一次drawFrame流程

# 顶点数据描述

* 之前顶点数据直接放在shader中，现在我们要定义在cpp中，传入到shader中
* 流程：
  * 顶点数据：将3个顶点的位置和颜色数据存放在数组中，每个元素都是Vertex自定义类型
  * VkVertexInputBinding
  * Description顶点输入绑定，包含绑定编号，字节间隔，顶点属性寻址是依赖于逐顶点还是逐实例
  * VkVertexInputAttributeDescription顶点输入属性描述，包含数据的绑定编号，着色器输入位置编号，数据的尺寸和类型，相对于顶点输入绑定的元素起始位置的字节偏移量（通过offsetof（class 类型，类成员），获取成员的偏移量）
  * VkPipeline：在VkPipelineVertexInputStateCreateInfo中，为vertexBindingDescriptionCount,vertexAttributeDescriptionCount设置数量和数据
  * shader：把vs中定义的顶点数据删除，改为layout(location = index) in 从外部输入

# VkBuffer、VkDeviceMemory

* VkDeviceMemory物理设备内存：从GPU的memoryHeaps上分配的内存，抽象出来让我们自己定义分配策略
* VkBuffer缓冲：GPU上分配的内存的关联绑定，以及指定此内存的相关描述（使用方式,共享模式）
* 流程：
  * 初始化：
    * 创建VkBuffer：VkBufferCreateInfo，包含缓冲区的大小（以字节为单位），指定缓冲区的允许使用方式（VK_BUFFER_USAGE_VERTEX_BUFFER_BIT缓冲区用于vkCmdBindVertexBuffers），指定当多个队列家族访问缓冲区时的共享模式（独占 / 共享），vkCreateBuffer创建缓冲区
    * VkMemoryRequirements内存需求，包含所需内存量的大小（根据VkBuffer使用vkGetBufferMemoryRequirements获取），以字节为单位，缓冲在已分配的内存区域中开始的字节偏移量，需求的内存类型
    * 分配VkDeviceMemory：VkMemoryAllocateInfo内存分配，包含分配的字节数为VkMemoryRequirements的大小，从VkMemoryRequirements获取内存类型索引（vkGetPhysicalDeviceMemoryProperties获取物理设备所有内存属性（返回结果结构体包含两个数组 memoryTypes 和 memoryHeaps这个内存用来存放数据分为不同的内存类型，目前只关心memoryTypes），检查Requirements的内存类型索引，和是否有VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT标志以便可以写入，如果有返回对应索引），vkAllocateMemory创建内存
    * 关联：vkBindBufferMemory将VkBuffer和VkDeviceMemory绑定，关联起来
    * 填充VkDeviceMemory：vkMapMemory将GPU上分配的内存映射到CPU可访问的内存(下面将称为映射内存)中，vkUnmapMemory取消映射，内部通过memcpy将顶点数据填充到GPU上分配的内存中
    * 要注意：驱动程序可能不会立即将数据复制到缓冲内存中，导致内存中不可见，解决问题分为两种办法：
      * 内存类型VK_MEMORY_PROPERTY_HOST_COHERENT_BIT内存类型，这可能导致比显式刷新稍差的性能
      * 在写入映射的内存后调用 vkFlushMappedMemoryRanges，在从映射的内存读取之前调用 vkInvalidateMappedMemoryRanges
  * 每帧：
    * 绑定：在recordCommandBuffer中，vkCmdBindVertexBuffers绑定顶点缓冲
    * drawcall中，使用顶点数据的大小
  * 销毁：vkDestroyBuffer，vkFreeMemory

# 暂存缓冲区

* 此标记VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT的内存可以被CPU写入，但是GPU读取会较慢，此标记VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT的内存不可被被CPU写入，但是GPU读取会较快，因此我们首先创建HOST_VISIBLE的CommandBuffer，然后将vertex数据写入，然后将数据copy到DEVICE_LOCAL的CommandBuffer中，以便被GPU快速读取
* 缓冲区复制命令需要支持传输操作的queueFamily，任何具有 VK_QUEUE_GRAPHICS_BIT 或 VK_QUEUE_COMPUTE_BIT 功能的queueFamily,都已经隐式支持 VK_QUEUE_TRANSFER_BIT
* 流程：
  * 初始化：
    * 先创建staging暂存的VkBuffer和VkDeviceMemory，它的flag包括之前使用的VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT和VK_MEMORY_PROPERTY_HOST_COHERENT_BIT，还要新增VK_BUFFER_USAGE_TRANSFER_SRC_BIT源，最后将vertex数据存储在staging的Memory中
    * 再创建非staging的VkBuffer和VkDeviceMemory，有VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT标志
    * 拷贝buffer：
      * 创建新的CommandBuffer，和之前一样使用VkCommandBuffer调用vkAllocateCommandBuffers
      * vkBeginCommandBuffer，调用vkCmdCopyBuffer,大小指定为vertex数据的大小
      * 此命令需要提交到queue上执行，vkQueueSubmit，info中也要引用CommandBuffer
  * 销毁：使用完staging版本的，和CommandBuffer，就可以立即销毁了

# 索引缓冲

* 现在绘制矩形，顶点需要6个，可以用索引缓冲解决这个问题，现在需要4个顶点
* 流程：
  * 初始化:
    * 修改vertex数据，新建indices数据
    * 新建indices的VkBuffer和VkDeviceMemory，和vertex一致，不同点就是数据的改变
    * 在recordCommandBuffer中和vertex一样，也要vkCmdBindIndexBuffer绑定缓冲
  * 销毁：vkDestroyBuffer，vkFreeMemory