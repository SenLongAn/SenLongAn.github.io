---
title: 4·堆栈队列、排序算法
date: 2025-07-29 12:00:00 +0800
categories: [算法与数据结构]
tags: []     # TAG names should always be lowercase
math: true
---

# 堆栈队列

### 堆栈

![1742953195101](/assets/img/blog/c++/堆栈图解.png)

堆/队列：队头做删除操作,在队尾做插入操作

栈：仅能在栈顶进行插入和删除操作，把另一端称为栈底

### priority_queue

**定义：**

priority_queue< type, container, function>元素类型，底层容器（缺省），比较方式（缺省）

元素根据其优先级大小有序排列，优先级高的元素会优先出队，而不是像普通队列那样遵循先进先出（FIFO）原则

优先队列也称为堆heap，分为大顶堆和小顶堆（本质由数组实现，默认是最大堆），堆的本质是完全二叉树

**完全二叉树：**

* 满二叉树：满二叉树是一种特殊的的完全二叉树，所有层的结点个数都是最大值
* 完全二叉树：除最后一层外，其他层的结点个数全部达到最大值，且最后一层的结点从左侧填充
* 父节点索引i：左孩子:2 * i + 1, 右孩子:2 * i + 2
* 左/右节点i：父节点：(i-1)/2

**大顶堆和小顶堆**

![1742953921414](/assets/img/blog/c++/堆_数组表示.png)

![1742953916407](/assets/img/blog/c++/堆_二叉树表示.png)

大顶堆：arr(i)>arr(2 * i+1) && arr(i)>arr(2*i+2),每个结点的值都大于其左孩子和右孩子结点的值

小顶堆：arr(i)< arr(2 * i+1) && arr(i)< arr(2*i+2),每个结点的值都小于其左孩子和右孩子结点的值

**比较函数：**

c++提供了两个内置比较函数：less->构造大根堆->降序（默认），greater->构造小根堆->升序

# 算法复杂度分析
  
* 性能测试：在编写程序后算法性能测试，精确性高，算法编写好运行，依赖数据规模
* 算法性能分析：在编写程序前对算法性能估计，精确性低，使用方便，不依赖数据规模
* 四则运算：
  * ……
* 化简：
  * 每局指令执行时间均设为1
  * 加法常数项可以忽略
  * 除去最高阶项，其它次项可以忽略
  * 与最高次项相乘的常数可以忽略
  * 用常数1取代运行时间中的所有加法常数
* 算法复杂度与数据规模之间的增长关系，它并非实际执行时间/存储空间（具体数值），而是反应一种趋势（n相关的表达式）
* 渐进记号：
  * Θ，读音：theta、西塔；既是上界也是下界(tight)，等于，平均情况复杂度
  * Ο，读音：big-oh、欧米可荣（大写）；表示上界(tightness unknown)，小于等于，最坏情况复杂度
  * ο，读音：small-oh、欧米可荣（小写）；表示上界(not tight)，小于
  * Ω，读音：big omega、欧米伽（大写）；表示下界(tightness unknown)，大于等于，最好情况复杂度
  * ω，读音：small omega、欧米伽（小写）；表示下界(not tight)，大于
* 步骤：四则运算 -> 化简 -> 渐进记号
* 最好情况复杂度：用最理想的情况四则运算
* 最坏情况复杂度：用最不理想的情况四则运算
* 平均情况复杂度：把所有情况四则运算的和 / 所有情况个数
* 均摊时间复杂度：一个算法的复杂度比较高，但是该算法是和其它操作是一起的，这个较高复杂度的算法，需要将其均摊到其它操作上，
  * 比如执行n次，每次复杂度是1，最后一次，复杂度是n，总共是2n，2n / n次，每次操作的平均耗时为1
* log2^n: log2^1 = 0, log2^2 = 1, log2^4 = 2, log2^8 = 3, log2^16 = 4, log2^32 = 5, log2^64 = 6, log2^128 = 7
* 常见的时间复杂度T(n)
  * O(1):算法执行时间不会随着数据量改变
  * O(logn)：满足logx^n次的循环
  * O(n): 一层循环
  * O(nlogn): logx^n次的循环，嵌套一层循环
  * O(n^2): 二层循环
  * O(n^3): 三层循环
* 空间复杂度S(n)
  * O(1): 变量
  * O(n): 一维数组
  * O(n^2): 二维数组

# 排序算法

![6](/assets/img/blog/algorithm/排序算法复杂度.png)

### 算法复杂度

* In-place：原地算法，指的是占用常用内存，不占用额外内存。空间复杂度为 O(1) 的都可以认为是原地算法
* Out-place：非原地算法，占用额外内存
* 稳定性：排序列中两元素相等，排序前后这两个相等元素的相对位置不变，则认为是稳定的
* k：“桶”的个数

### 冒泡排序（Bubble Sort）（比较排序）

  ```c++
  #include <iostream>
  using namespace std;

  void BubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
      for (int j = 0; j < n - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          swap(arr[j], arr[j + 1]);
        }
      }
    }
  }

  int main() {
    const int n = 9;
    int arr[n];
    for(int i = 0; i < n; i++) {
      cin >> arr[i];
    }
    //BubbleSort(arr, n);
    //SelectionSort(arr, n);
    //InsertionSort(arr, n);
    //MergeSort(arr, 0, n - 1);
    //QuickSort(arr, 0, n-1);
    //HeapSort(arr, n);
    //CountingSort(arr, n);
    //BucketSort(arr, n, 3);
    RadixSort(arr, n);
    for (int i = 0; i < n; i++) {
      cout << arr[i] << " ";
    }
    cout << endl;
    return 0;
  }

  //测试用例
  // 2 3 1
  // 2 3 1 4
  // 2 2 1 4
  // 8 5 9 10 5 3 15 1 2  n == 9
  ```

  * 每次从n - i个未排序数列中找到值最大的元素，放在已排序数列的左侧n - i索引的位置
  * 未排序数列在左，已排序数列在右

### 选择排序（Selection Sort）（比较排序）

  ```c++
  void SelectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
      int curIndex = i;
      for (int j = i + 1; j < n; j++) {
        if (arr[j] < arr[curIndex]) {
          curIndex = j;
        }
      }
      swap(arr[i], arr[curIndex]);
    }
  }
  ```

  * 每次从n-i个未排序数列中找到值最小的元素，放在已排序数列的右侧i索引位置
  * 未排序数列在右，已排序数列在左
  * 在查询过程中和BubbleSort不同的是，非通过swap查询最值元素

### 插入排序（Insertion Sort）（比较排序）

  ```c++
  void InsertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
      for (int j = i; j > 0; j--) {
        if (arr[j] > arr[j - 1]) {
          break;
        }
        swap(arr[j], arr[j - 1]);
      }
    }
  }
  ```

  * 每次将i索引元素插入到左边从i开始已排序数列中
  * 未排序数列在右，已排序数列在左

### 归并排序（Merge Sort）（递归）

  ```c++
  void Merge(int arr[], int m, int l, int r) {//合并
    int* temp = new int[r - l + 1];
    int i = l, j = m + 1, index = 0;
    while (i <= m && j <= r) {
      if (arr[i] < arr[j]) {
        temp[index] = arr[i];
        i++;
      }
      else {
        temp[index] = arr[j];
        j++;
      }
      index++;
    }
    while (i <= m) {
      temp[index] = arr[i];
      i++;
      index++;
    }
    while(j <= r) {
      temp[index] = arr[j];
      j++;
      index++;
    }
    for (int i = 0; i < r-l+1; i++) {
      arr[l + i] = temp[i];
    }
    delete[] temp;
  }

  void MergeSort(int arr[], int l, int r) {
    //基本返回情况
    if (l >= r)return;

    //状态转移
    int m = (l + r) / 2;
    MergeSort(arr, l, m);//分解
    MergeSort(arr, m + 1, r);
    Merge(arr, m, l, r);
  }
  ```

  * 递归
    * 函数功能：对l到r的数列排序
    * 基本情况：数列只有一个元素
    * 状态转移：分解为2组有序序列，再合并为1组有序序列

### 快速排序（Quick Sort）（递归）

  ```c++
  void QuickSort(int arr[], int l, int r) {
    if (l >= r)return;
    int pivot = arr[l];
    int i = l, j = r;
    while (i < j) {
      while (i < j && arr[j] >= pivot)j--;
      while (i < j && arr[i] <= pivot)i++;//i指令要放在j指令后面
      if(i < j)swap(arr[i], arr[j]);
    }
    swap(arr[l], arr[i]);
    QuickSort(arr, l, i - 1);
    QuickSort(arr, i + 1, r);
  }
  ```

  * 每次从未排序数列中选择一个元素称为 “基准”，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面
  * 递归：
    * 基本情况：数列只有一个元素
    * 状态转移：按照基准划分后，继续对左右数列分别快排
  * 要注意ij交点的情况，
    * 如果ij中间元素为0个，先让j--，i不变，i与l交换正确
    * 如果ij中间元素为1个
      * 如果这个值属于j侧，j-2，i不变，i与l交换正确
      * 如果这个值属于i侧，j-1，i++，i与l交换正确

### 堆排序（Heap Sort）（递归）

  ```c++
  void AdjustHeap(int arr[], int l, int r) {//调整堆
    if (l >= r)return;//少于一个节点不用调整
    int left = 2 * l + 1, right = 2 * l + 2, index = l;
    if (left <= r && arr[index] < arr[left])index = left;//超过r之外的已排序数列不调整
    if (right <= r && arr[index] < arr[right])index = right;
    if (index != l) {
      swap(arr[l], arr[index]);
      AdjustHeap(arr, index, r);//超过r之外的已排序数列不调整
    }
  }

  void BuildMaxHeap(int arr[], int n) {//构建堆
    for (int i = n / 2 - 1; i >= 0; i--) {
      AdjustHeap(arr, i, n - 1);
    }
  }

  void HeapSort(int arr[], int n) {
    BuildMaxHeap(arr, n);
    swap(arr[0], arr[n - 1]);
    for (int i = n - 2; i > 0; i--) {
      AdjustHeap(arr, 0, i);
      swap(arr[0], arr[i]);
    }
  }
  ```

  * 索引：
    * 父i，左孩子2*i+1，右孩子 2 *i+2
    * 孩子i，父(i-1)/2
    * 最后一个非叶节点（最后一个叶节点的父节点）：第n层节点的数量 是<= n-1层节点数量 + 1，所以它的索引为 节点总数n/2-1
  * 步骤：
    * 映射（不用实际操作）：无序数列数组 映射到完全二叉树，堆从左往右读取，树自顶向下，从左到右写入（一行行写）
    * 构造大根堆：从以最后一个非叶节点为根的树开始，调整堆，直到以索引0为根的树调整完成为止
      * 调整堆（递归）：
        * 使用场景和作用：在左右子树都为大根堆情况下，对根节点调整，使得整体重建为大根堆
        * 算法：若左右节点最大值 > 根节点值，则交换，并对子节点中被交换节点为根的树 递归调用调整堆
    * 交换：对于大根堆 确定了未排序数列中的最大值元素，在根节点位置，通过它与第n - i个元素交换，从后往前放，作为已排序数列
    * 排序：现在对于未排序数列中，左右子树仍是大根堆，但被交换后的根节点不在正确的位置，通过调整堆可以重建大根堆，获得新的最大值元素并交换，……循环直到排序完成

### 计数排序（Heap Sort）（存放分配）

  ```c++
  void CountingSort(vector<int>& arr, int n) {
    int mi = INT_MAX, ma = INT_MIN;
    for (int i = 0; i < n; i++) {
      if (arr[i] < mi)mi = arr[i];
      if (arr[i] > ma)ma = arr[i];
    }

    int count = ma - mi + 1;
    vector<int> c(count);
    for (int i = 0; i < n; i++) {
      c[arr[i] - mi]++;
    }
    for (int i = 1; i < count; i++) {
      c[i] += c[i - 1];
    }

    vector<int> d(n);
    for (int i = 0; i < n; i++) {
      d[--c[arr[i] - mi]] = arr[i];
    }
    for (int i = 0; i < n; i++) {
      arr[i] = d[i];
    }
  }
  ```

  * 找出待排序的数据中最大和最小的元素，确定额外开辟的C数组(计数器)空间的范围，
  * 并遍历数据对C数组计数C
  * 对C数组所有的计数累加，确定区域右端位置
  * 遍历元素分配给D数组
  * D数组复制给原数组

### 桶排序（Bucket Sort）（存放分配）

  ```c++
  void BucketSort(int arr[], int n, int k) {
    int mi = INT_MAX, ma = INT_MIN;
    for (int i = 0; i < n; i++) {
      if (arr[i] < mi)mi = arr[i];
      if (arr[i] > ma)ma = arr[i];
    }

    //存放
    k = (k <= 0 || k > n) ? n : k;
    int elementCount = ma - mi + 1;
    int maxElementForOneBucket = elementCount / k;
    k = (elementCount % k != 0) ? k + 1 : k;
    vector<vector<int>> buckets(k);
    for (int i = 0; i < n; i++) {
      int index = (arr[i] - mi) / maxElementForOneBucket;
      index = (index > k) ? k : index;
      buckets[index].push_back(arr[i]);
    }

    //排序
    for (int i = 0; i < k; i++) {
      CountingSort(buckets[i], buckets[i].size());
    }

    //分发
    int index = 0;
    for (int i = 0; i < k; i++) {
      for (int j = 0; j < buckets[i].size(); j++) {
        arr[index++] = buckets[i][j];
      }
    }
  }
  ```

  * 映射函数：将数据映射到桶中的函数，它决定算法的效率
  * 确定数据范围
  * 创建桶，
  * 存放元素
  * 分别对每个桶元素排序（使用其他排序算法）
  * 数据拼接

### 基数排序（Radix Sort）（存放分配）

  ```c++
  #include <vector>
  #include <cmath>
  void RadixSort(int arr[], int n) {
    //最大值最小值
    int mi = INT_MAX, ma = INT_MIN;
    for (int i = 0; i < n; i++) {
      if (arr[i] < mi)mi = arr[i];
      if (arr[i] > ma)ma = arr[i];
    }
    
    //如果有负数，整体+abs（min复数）
    int offset = 0;
    if (mi < 0) {
      for (int i = 0; i < n; i++)arr[i] += (-mi);
      ma += (-mi);
      mi += (-mi);
      offset = (-mi);
    }

    //统计最大位数
    int maxBit = 0, temp = ma;
    while (temp != 0) {
      temp /= 10;
      maxBit++;
    }

    //存放+分配
    vector<vector<int>> vec(10);
    for (int i = 0; i < maxBit; i++) {
      //存放
      for (int j = 0; j < n; j++) {
        int index = arr[j] % (int)pow(10, i + 1) / (int)pow(10, i);
        vec[index].push_back(arr[j]);
      }
      //分配
      int index = 0;
      for (int j = 0; j < 10; j++) {
        for (int k = 0; k < vec[j].size(); k++) {
          arr[index++] = vec[j][k];
        }
        vec[j].clear();
      }
    }

    //如果有负数，整体-abs（min复数）
    if (offset != 0) {
      for (int i = 0; i < n; i++)arr[i] -= offset;
      ma -= offset;
      mi -= offset;
    }
  }
  ```

  ![6](/assets/img/blog/algorithm/基数排序.png)


  * 按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位（右侧是低位）
  * 每一次外循环，相当于把当前排序位按照从小到大的顺序排列存放