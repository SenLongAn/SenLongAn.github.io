---
title: c++(7`数据类型的大小、size_t/sizeof/strlen)
date: 2025-04-01 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---
# 数据类型的大小

![1743508607402](/assets/img/blog/c++/数据类型的大小.png)

长度的单位为字节，右边是可表示的十进制数字范围

![1743579107423](/assets/img/blog/c++/不同位系统.png)

不同位系统，long的字节数可能不同

# size_t

size_t 是一种平台相关的无符号整数类型，足够容纳任何对象大小的无符号类型，在32位系统上，它通常是4字节的unsigned int；而在64位系统上，它通常是8字节的 unsigned long

_32 位和 64 位指的是计算机处理器的字长，字长是计算机能直接处理的二进制数据的位数，它决定了计算机的运算精度、数据处理能力和寻址空间_

```c++
size_t size = sizeof(double); //标准库兼容性
size_t length = vec.size();//标准库兼容性

int arr[5000000000];//对象数量
for (size_t i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) { 
}
const size_t huge_size = sizeof(……); //内存大小
```

size_t足够容纳任何对象大小的无符号类型：

假设是32位系统，size_t表示的范围是0——4294967295

按字编址，地址总线的位数是32，即寻址范围共2^32字节 == 4,294,967,296 字节 == 4G

也就是说一个对象最大的sizeof值不会超过4,294,967,296，size_t恰好可以存储

作用：

* 标准库兼容性：C++标准库中的许多函数和操作都会使用size_t作为返回类型，
* 用于循环计数，避免因使用 int而可能导致的溢出问题,比如 int arr[5000000000]，这个在64位是可以存储下的，数组的个数是5000000000，因此int不支持，而size_t此时相当于 long，确保代码的可移植性和安全性
* 需要注意的是，它是unsigned的，因此不要和signed混用，会产生错误的结果，并且具有逻辑上的非负性，所以通常用来**表示内存大小/对象数量，而非需要运算的情况**


# sizeof和strlen

```c++
int *arr = (int *)malloc(n * sizeof(int)); 
size_t personSize = sizeof(struct Person); 
size_t arrLength = sizeof(arr) / sizeof(arr[0]); 
```

sizeof()是运算符，

* 返回一个对象/类型所占的**内存大小**，单位是字节，数可以是数组、指针、类型、对象、函数等，
* 其值在编译时 就已经计算好了，因此参数不可以是动态分配的对象
* 通常用于为静态类型分配足够的空间，免除了复杂的计算
* 帮我们计算复杂类型的大小
* 计算数组的元素个数

```c++
char str[] = "Hello, World!";
size_t length = strlen(str); 
```

strlen(…)是函数，

* 要在运行时 才能计算。参数必须是字符型指针（char*）
* 一般用于返回**字符串的实际长度**

```c++
void Test1()
{
	char p[] = "hello";//5,6
	cout << "p: " << p << "   " << strlen(p) << "   " << sizeof(p) << endl;
	char p1[] = "hello\0";//5,7
	cout << "p1: " << p1 << "   " << strlen(p1) << "   " << sizeof(p1) << endl;
	char p2[] = "hello\\0";//7,8,第一个\是转义\0的，所以它不算字符，它会让后面的\0变为普通的字符
	cout << "p2: " << p2 << "   " << strlen(p2) << "   " << sizeof(p2) << endl;
	char p3[] = "hello\\\0";//6，8，第一个\只转义了第二个\，使得第二个\不能再转义后面
	cout << "p3: " << p3 << "   " << strlen(p3) << "   " << sizeof(p3) << endl;
	char p4[] = "hel\0lo";//3，7
	cout << "p4: " << p4 << "   " << strlen(p4) << "   " << sizeof(p4) << endl;
	char p5[] = "hel\\0lo";//7，8
	cout << "p5: " << p5 << "   " << strlen(p5) << "   " << sizeof(p5) << endl;
}
```

注意：strlen 计算的是字符串的实际长度，遇到\0（空字符）即停止；sizeof 计算整个字符串所占内存字节数的大小，当然\0也要+1计算

# 正、反、双反 斜杠

正斜杠（/）: 支持跨平台

反斜杠（\）：Windows原生路径分隔符, \也是转义前导字符，用于和后面跟随的字母构成转义字符，因此通常不会直接使用它，而是会使用\ \

双反斜杠（\ \）：一个\后面是\，那么第一个\会起到避免第二个\转义的作用

# 计算机基础

字长 == 计算机一次能处理的二进制数据的位数
存储容量 == 总内存
寻址范围 == 存储单元数量，根据地址总线的位数决定的，2的N次方
按字编址：意味着以字节为单位对存储单元进行编号，也就是每个地址对应一个字节

# 嵌套类

C++ 允许在一个类（外部类）内部定义另一个类（嵌套类）

独立作用域：嵌套类是一个独立的类，只是定义在外部类的作用域内。

无特殊访问权限：嵌套类默认不能直接访问外部类的非静态成员（除非通过指针或引用）。

可访问静态成员：嵌套类可以直接访问外部类的 static 成员。