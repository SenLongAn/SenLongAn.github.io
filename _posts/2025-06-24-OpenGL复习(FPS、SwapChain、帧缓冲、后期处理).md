---
title: OpenGL复习(FPS、SwapChain、帧缓冲、后期处理
date: 2025-06-24 12:00:00 +0800
categories: [OpenGL]
tags: []
math: true
---

## 屏幕刷新率， FPS，垂直同步VSync

![alt text](/assets/img/blog/Graphic/刷新率_交换链_FPS.png)

* 屏幕刷新率：每秒显示器刷新画面的次数，单位HZ，它是由硬件层面决定的，无论当前画面是否准备好，都会以固定的节奏强制刷新，每次刷新时从swapchain的fontbuffer逐行扫描读取
* 帧率FPS/渲染速率：每秒渲染图像的次数，渲染完一张图像就会接着渲染下一张，它是由硬件软件很多因素决定的，每秒都是不固定的，逐行写入到swapchain的BackBuffer中
* 垂直同步（VSync）：强制在显示器刷新完成后再交换缓冲区
* 画面撕裂：在读取过程中，并非读取同一帧数据，出现的画面割裂现象

## 交换链

* 管理多个缓冲区，双缓冲区有两个缓冲，三缓冲区有三个缓冲，首个buffer作为screenbuffer/font buffer，其余buffer为back buffer
* 呈现/交换：当BackBuffer渲染完成，会执行交换操作，首个backbuffer取代screenbuffer，screenbuffer取代末尾backbuffer
* 作用：
  * 一个缓冲
    * 没有强制同步（渲染完成后即可写入下一帧，以固定HZ读取）
      * 帧率 > 屏幕刷新率，画面撕裂
      * 帧率 < 屏幕刷新率，画面撕裂
    * 强制同步（渲染完成后应该等待，直到读取完成后，才可写入下一帧，以固定HZ读取）
      * 帧率 > 屏幕刷新率，GPU被强制等待，浪费了GPU的算力
      * 帧率 < 屏幕刷新率，画面撕裂
  * 两个缓冲
    * 没有VSync（在backbuffer写入，渲染完成就执行交换，以固定HZ在font buffer读取）
      * 帧率 > 屏幕刷新率，画面撕裂
      * 帧率 < 屏幕刷新率，卡顿，画面撕裂
    * VSync（在backbuffer写入，渲染完成需要等待读取完成后，才可交换，以固定HZ在font buffer读取）
      * 帧率 > 屏幕刷新率，浪费GPU算力
      * 帧率 < 屏幕刷新率，卡顿
    * 相对于一个缓冲，它可以提升GPU的利用率，减少卡顿的现象
  * 三个缓冲

## 帧缓冲

* 帧缓冲区是所有缓冲区的组合，所有缓冲区的采样点数量都应该一致
* 离屏渲染：渲染到非默认帧缓冲（非直接输出到屏幕）
* 附件
  * 纹理附件：
    * 创建纹理并设置纹理属性
    * glFramebufferTexture2D把纹理绑定到帧缓冲，并设置附件类型：颜色/深度/模板
    * 一个帧缓冲可以添加多个颜色附件，但深度/模板只能添加一个
    * 可被读写
  * 渲染缓冲对象附件：
    * glRenderbufferStorage创建并设置渲染缓冲对象
    * glFramebufferRenderbuffer把渲染缓冲对象绑定到帧缓冲，并设置附件类型：颜色/深度/模板
    * 它会将数据储存为OpenGL原生的渲染格式，仅可写不可读，写入/复制它的数据很快
* 使用场景
  * 阴影贴图
  * 后期处理
  * 镜子高度反射物体
  * MRT
  * ……

## 卷积

* 卷积核（Kernel），一个a行b列的矩阵，每个元素作为权重值
* 对源纹理卷积，输出新纹理：对每个像素，以自身为中心取a行b列的像素区域，区域中每个像素和卷积核对应权重值相乘，求和，除以像素个数取平均值，计算结果作为新纹理的像素值

## 后期处理

* 渲染完成整个场景，对获得的纹理，通过新pass后期处理阶段处理，获得新纹理
* 反相：1-颜色值
* 灰度：让rgb值一致，这样就形成黑白灰，不同亮度值，根据不同原色*相同浮点决定
* 锐化：卷积
* 模糊：卷积
* 边缘检测：卷积