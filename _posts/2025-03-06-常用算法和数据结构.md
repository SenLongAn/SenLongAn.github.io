---
title: 常用算法和数据结构
date: 2025-03-06 12:00:00 +0800
categories: [算法]
tags: []     # TAG names should always be lowercase
math: true
---
# 并查集

并查集使用**树形**数据结构，用于处理**不相交集合**的**合并及查询**问题，从而加快查询效率（比如pq元素是否属于同集合）

经典问题：亲戚/朋友问题：例如(a,b) 即a是b的朋友，且(b,c)，则abc互为朋友关系

数据结构：通常由数组实现

算法:

此处元素整形，如果是string，应使用unordered_map<string, string>

* init():初始化

```c++
void init(int n)
{
    for (int i = 1; i <= n; ++i)
        parents[i] = i;//元素i的父节点为本身，每个元素单独为一个集合
}
```

* merge(p,q): 把两个不相交的集合合并为一个集合

  每棵树表示一组集合，一旦两个元素所在的根节点组成父子关系，那么两者所在的集合将合并为一个集合

```c++
void merge(int i, int j)
{
    parents[findRoot(i)] = findRoot(j);//i的根节点指向j的根节点，变为同一集合
}
```

* findRoot(p): 查找p所在集合的根节点

```c++
int findRoot(int x)
{
    return x == parents[x] ? x : findRoot(parents[x]);//如果x是根节点直接返回，否则递归查询父节点
}
```

* isConnected(p,q):查询两个元素是否在同一个集合中

```c++
bool isConnected(p,q)
{
    return findRoot(p) == findRoot(q);//如果两个元素根节点相同，则在一个集合中
}
```

* 路径压缩：在查询节点p的根节点q时，如果pq路径很长，每次都要花费很多查询时间，如何保证查询时间复杂度只需要O(1)呢？

  每次的findRoot都相当于对树的重构，所有以q为根树内的节点，全部重构为直接指向q，从而在以后的findRoot时，可以一步到位

```c++
int findRoot(int x)
{
    return x == parents[x] ? x : (parents[x] = findRoot(parents[x]));
}
```

# 字典树

字典树/前缀树：使用**树**形数据结构，保存大量的**字符串**，每个从根节点开始的**路径**（不一定到叶结点）表示一个字符串，从而加快查询效率

数据结构：通常每个node既包含本身字符，又包含子节点数组

算法：

* 构建:
* 插入:
* 查询:

# 其他常见算法和数据结构：

* 暴力，循环，递归（深搜dfs，回溯），二分查找，动态规划dp，贪心，双指针，快慢指针，滚动数组，滑动窗口，广度bfs，分治，并查集（合并，查询），前缀和，排序（拓步，归并，计数，桶，基数）
* 字符串，堆栈，单调栈，哈希，集合，数组（1.2维），队列（优先队列），链表（双向），矩阵，树（N叉树），字典树，图，空间数据结构
