---
title: Games202(2·第4章，第5章)
date: 2025-01-04 12:00:00 +0800
categories: [Games202]
tags: [实时渲染]     # TAG names should always be lowercase
math: true
---
# 第4章

##### 优化性能

如何优化pcf以及pcss的性能呢，在区域计算时，随机采样指定数目的像素，而不是区域内的所有像素，但是这样会导致噪声，

另一种方法不再计算区域内的每个像素（比如8*8=64），而是通过转为正太分布的pdf，估计概率，这就是vssm

##### vssm （variance soft shadow mapping）方差软阴影映射

vssm正是为了解决软阴影实现的性能问题，那么为了映射为正太分布，我们需要求出曲线的均值，和方差，然后求出pdf中满足一定区域的概率

**求均值：**
* mipmap：它只能在正方形内查询，并且它是不准的
* SAT（summed area tables）：可以在长方形查询，结果是准确的
  * sat算法是为了解决快速区域查询的，它的思想是前缀和表

![1736083266125](/assets/img/blog/Games202/2d区域查询.png)

  * 为了理解，我们首先看一维，比如我要快速获取原数组的和，可以通过新建一个前缀和数组（遍历n次，每次累加的值存储到新数组中），在区域查询时直接从新数组获取ab的索引，两者相减即可
    * 对于2维同样，不过ij的值需要：（K为区域的半径）
    * sum = P[i + K + 1][j + K + 1] - P[i - K][j + K + 1] - P[i + K + 1][j - K] + P[i - K][j - K]
    * 对于查询时需要：[i + K, j + K] - [i - K, j + K] - [i + K, j - K] + [i - K, j - K]

**求方差：**
我们利用了公式：x平方值的期望 - x期望值的平方 = 方差

因为shadowmap中存储的depth就是x，区域的均值就是期望，因此只需要在计算shadowmap时，额外生成一张shadow map，它保存的是depth^2即可
  
**求概率**

CDF : 累积分布函数,是pdf的积分 == 函数的面积

![1736083528679](/assets/img/blog/Games202/切比雪夫不等式.png)

但是也可以通过切比雪夫不等式 在知道 期望 和 方差 时候 近似求得x > t（必须在均值的右边）时的概率

# 正太分布

![1736083686852](/assets/img/blog/Games202/正太分布图像.png)

对于连续性随机变量X（样本到实数映射的函数），其中ab区间的概率 == ab区间的面积

正态分布又称高斯分布函数：通常会呈现钟形曲线，中间区域概率高，两侧的概率低，且不想左右偏移：
* 平均值 = 中位数 = 众数
* 沿中线对称
* 50% 的值小于平均值，50%的值大于平均值

正太分布由几个概念组成：

* 均值μ：决定了正态分布曲线的中心位置，也是分布的期望值
* 标准差σ：决定了正态分布曲线的形状，标准差越大，曲线越分散；标准差越小，曲线越集中
* 方差σ^2:方差是标准差的平方，表示数据离散程度的度量

# 第5章

## SDF（Signed Distance Function）

函数返回空间中任何一点,到某个物体的最小距离，sdf（p）= d，其中返回值有正负，负数代表在物体内部,正数则表示在物体外部（是一个矢量）

应用：

**Ray Marching光线步进：**

如同光栅化/ray tracing一样，它也是渲染的一种方式，类似光线追踪，都是找到光线在scene中的交点，但不同的是，它是按照步进的方式，而不是一次性的和场景求交

![1736574836494](/assets/img/blog/Games202/ray%20marching.png)

那么每次走多远呢？为了保证不会超过物体，每次走sdf的距离，可以看图，从p0点以sdf为半径画圆，沿着光线方向走sdf的距离到达p1点，……逐渐步进

直到距离物体足够接近求交，或者步进超过了指定次数，还距离物体非常远，停止步进

**软阴影**

我们知道不同的shading point阴影的过滤程度不同（和遮挡物和被投射物体的距离有关），我们前面对pcss做了优化vssm，但是我们一般不会使用vssm，还有其他方式生成软阴影，我们将利用sdf

![1736574861565](/assets/img/blog/Games202/safe%20angle.png)

以着色点p为起点和光源连线，以sdf（p）为半径画圆，在以p为起点和圆做切线，这里的连线和切线的夹角就是safe angle

safe angle越小，阴影越黑,越趋近于硬阴影;afe angle越小，阴影越黑,越趋近于硬阴影;

可以想象随着遮挡物和被投射物体的距离越近，sdf越小，那么safe angle越小，阴影越趋近于硬阴影，完全符合软阴影的性质

![1736574889255](/assets/img/blog/Games202/计算safe%20angle.png)

但是如何求出这个safe angle呢？

* 我们可以求出圆的半径 = sdf(p)，可以求出p-0,那么利用反正弦函数arcsin（正弦：sin(theta) = float, arcsin(float) = theta）就可以轻松求出夹角
* 但是arcsin非常消耗性能，因此用另一种方法，其中k越小,半影区域越大,越接近软阴影效果.K越大,半影区域越小,越接近硬阴影效果.

## environment lighting
**基于物理的直接光照**

不用考虑半球，直接计算brdf即可

**预计算环境贴图**

那么如何通过**光栅化**渲染**实现环境光**呢，一种简单的做法是使用IBL(image-based lighing)环境贴图去做，它通常用cubemap存储，颜色值即环境光照

**拆分简化1**
要实现基于物理的环境光（直接 + 间接光照），我们会使用渲染方程计算颜色，我们首先不考虑阴影项（V项），它现在仅包含L和F的积分，通过brdf项展开，可以分解为漫反射和镜面反射两部分

![1739090985152](/assets/img/blog/Games202/拆分.png)

**拆分简化2**
每个部分仍包含LF的积分这不太好做，

对于漫反射部分，brdf项为常数可以直接拆出积分，

对于镜面部分则需要：

![1736781458359](/assets/img/blog/Games202/不等式.png)

根据微积分的不等式性质，两个函数乘积的积分 ~=约  两个函数积分的乘积，

这里解释下分母，例如假设fx为常数项，x的域为0--3，那么根据定积分公式，左侧相当于2 * gx， 右侧相当于 (2*3)/3 * gx, 分母正是为了让两侧结果一致

根据这个性质就可以把原本的积分项拆出来：如下

![1736781484119](/assets/img/blog/Games202/拆分的渲染方程.png)

**预计算贴图**

首先看L部分：

我们会预计算出辐照度图，因为光是从半球方向来的，就算转换为离散采样，计算量也非常庞大，因此预计算特定半球方向的总辐照度，（比如某shader point的法线方向下采样辐照度，即立即获得了半球方向的总辐照度）

另外对于粗糙度越高的物体，采样方向应该更分散，因此可以加入对辐照度图的模糊来实现

对于B项:

漫反射部分是常数，

但是镜面部分比较复杂，但我们也可以预计算，由于RDF 的法线分布函数(NDF)需要以视角方向作为输入，但在实时渲染时不能预先确定视线方向，因此假定视线方向 == 采样方向

我们需要简化大量的参数仅考虑FD（因为没有阴影），其中F可以化简一个基础反射率R0和入射角度的指数函数，D项仅考虑diffuse还是gloosy，以及half vector和法线中间的夹角

因此我们只剩下3个变量：基础反射率r0, roughness粗糙度 和theta角度 , 但是我们还需要化简，3维太大了
 
通过F项带入，可以将R0拆出积分式，只剩下两个参数了，可以绘制2维纹理，这样就可以直接查询了