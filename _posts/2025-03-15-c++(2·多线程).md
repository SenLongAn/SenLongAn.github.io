---
title: c++(2·多线程)
date: 2025-03-15 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---
# 多线程

## 基础概念

* 进程：正在运行的程序的实例，比如任务管理器中每个程序都是一个进程
* 线程：是进程中的实际运作单位，每个进程可以拥有至少一个的线程
* 同步：一个任务完成后另一个任务才能开始
* 异步：一个任务的开始和完成不会直接影响另一个任务的开始和完成
* 并发：有多个任务在单核CPU被处理，任务被交替执行
* 并行：有多个任务在多核CPU被处理，任务可以被同时执行

## 多线程

多线程是并发/并行的技术实现，使得程序能够在同一时间执行多于一个线程，进而提升整体处理性能，但是其实它并非一定会提升性能

* 单核处理CPU任务：多线程会时间切片，交替执行任务，这是并发的，CPU任务不能被异步处理，且任务调度需要时间，因此不会提高效率
* 单核处理CPU + GPU任务：由于GPU任务是可以并行的，因此可以在执行CPU任务时同时处理多个GPU任务，CPU和GPU两者之间是并行的，会提高效率
* 多核处理CPU任务：多个任务被异步处理，这是并行的，会提高效率

## std::thread

* thread()创建一个线程
* thread(Fn&& fn, Args&&… args)执行fn函数，以args为参数
* join()等待线程结束并清理资源
* joinable()线程是否可以执行join函数
* get_id()	获取线程id

如果函数的参数是有引用的，我们应该在thread创建时传入左值args，以便向引用形参传入实参，但args是右值引用，因此向它传入左值是会报错，利用std::ref和std::cref可以解决问题，它们分别可以包装按引用、const引用 传递的值

std::move是将左值强制转换为右值，这里我们依旧需要左值，因此不能用它，应用包装器

## std::atomic和std::mutex

## std::async

## std::future

## std::promise

## std::this_thread
