---
title: Games202(10`第13章)
date: 2025-03-16 12:00:00 +0800
categories: [Games202]
tags: [实时渲染]     # TAG names should always be lowercase
math: true
---
# 第13章

## Implementation of filtering过滤的实现

~C k = —C，noisy未降噪的 被kernel滤波（卷积核）处理 得到降噪后的

#### 高斯滤波(Gaussian filtering)

通过像素绝对距离确定权重，类似于正太分布，中心值高,向两边衰减，除去高频信息（变化剧烈的部分），整体模糊

伪代码：

![1742124018178](/assets/img/blog/Games202/伪代码.png)

* 对于每个像素i，找到周围的每个像素j
* 加权：对每个像素j，会根据绝对距离和标准差求得j权重，通过j值 * j权重 得到j对i的贡献值
* 平均：循环结束，i值 = sum_值 / sum_权重

#### 双边滤波(Bilateral filtering)

通过像素绝对距离、颜色确定权重，以便保留低频和边界高频（变化最剧烈的部分），整体模糊但**边界清晰**

也就是如果a和b信号（颜色）差距过大，那么让b对a的贡献减少，从而就不会出现边界的模糊情况

因此我们要更改权重的计算公式（随差值衰减的函数，比如高斯函数，差值越大，贡献越小）：

![1742110583668](/assets/img/blog/Games202/双边滤波.png)

i和j代表第一个像素位置,k和l代表另一个像素位置，I(i,j)表示第一个像素的颜色值,I(k,l)表示第二个像素的颜色值

括号中左边是距离影响，右边是颜色影响

#### 联合双边滤波(Joint Bilateral filtering)

我们刚才只考虑了颜色信息，如果考虑更多的特性，将得到更好的结果，

我们会利用G-buffer得到的颜色，法线信息，以及深度缓冲中的深度信息，对于每次计算b对a的贡献时，都会考虑这3者，如果某特性差距过大，那么让b对a此特性贡献减少，最后将3者贡献相乘，得到最后的权重值

#### 实现较大的过滤器Implementing Large filters

如果有一个较大的过滤器，filter速度会变得特别慢，如何让它变快呢？

**拆分实现Separate Passes**

![1742127531721](/assets/img/blog/Games202/拆分实现.png)

假如有一个N * N的高斯filters，我们需要计算N * N次，但现在我们把它在水平方向上的N个像素filter一遍,之后再在竖直方向上的N个像素filter一遍，将两者filter结果相乘，这样只需要N + N次，最后的结果是完全相同的

2D的高斯函数数学上本身就是可以拆分的G(x,y)=G (x) × G (y)

看这个图可以方便理解，首先在水平方向计算贡献，同样会在垂直方向计算贡献，两者相乘，相当于把水平的sum_Res，按照垂直的结果做一个乘积，也就是向上/下sum_Res会逐渐减小，最后形成了沿中心向四周逐渐变淡的效果，最后的sum_Res是一致的

**逐渐增长的尺寸Progressively Growing Sizes**



#### 离群值删除Outlier Removal

