---
title: Games202(9`第11章、第12章)
date: 2025-03-15 12:00:00 +0800
categories: [Games202]
tags: [实时渲染]     # TAG names should always be lowercase
math: true
---
# 第11章

## LTC线性变换的余弦

LTC：在多边形光源（面光源）快速求得不考虑V项任意一点的着色值

lobe/镜面波瓣：镜面BRDF的wi和wo任意一边固定，另一边形成的波瓣，从wi进入的光线向波瓣方向反射，从波瓣进来的光线向v方向反射

固定入射方向，把brdf的lobe通过线性变换M^-1转变为一个余弦函数，使得朝上

将多边形光源（每个顶点和p连接的向量）也进行M^-1变换使得朝上（需要归一化）

这样就将任意方向的brdf的lobe在任意多边形下的光源求积分问题，转化为在一个固定cos函数下对任意的多边形光源求积分的问题

![1742022634554](/assets/img/blog/Games202/LTC.png)

我们需要改写渲染方程，假设多边形光源任何radiance都是uinform一致的，因此作为常量可以提取到积分外，由于不考虑V项，积分内剩下F项和cos项组合一起，变为余弦函数，由于改变光源方向，M^-1*wi = wi\`，即为M\*wi`· = wi

现在无法解积分，需要把d项变为dwi`，因此引入雅克布项J

## Disney's principle BRDF迪士尼原则

microfacet models有一些问题

* 无法解释多层材质
* 让artist艺术家使用繁琐

设计原则

Disney's principle BRDF诞生的首要目的就是为了让artist使用方便,因此它遵守这些设计原则

* 使用更直观的名词而不是使用物理名词参数（次表面反射，金属度，镜面反射程度, 镜面反射+颜色,粗糙度,各向异性程度，光晕，光晕+颜色，透明层的明显程度，透明层的光泽层）
* 最好有一个拖动条让艺术家拖动，定义左右范围，为了特殊效果允许超过范围

优缺点：

* 优点：混合使用显示不同的材质，更容易理解的参数
* 缺点：并不是完全基于物理的，参数冗余

## NPR非照片真实感的渲染

照片真实感渲染：强调画面的真实感，无法分辨是照片还是渲染出来的

风格化渲染：做出艺术效果，远离真实感，它的做法首先渲染真实效果，再变为非真实效果

#### outline rendering 描边

* 基于法线着色:当v和n点乘结果小于某个阈值
* 基于几何:渲染一个更大的模型，整体颜色为描边色，不允许看见正面
* 基于模板测试：……
* 基于后期处理:先渲染一个正常的图像，利用kernel(卷积核)检测边缘，并对它们应用卷积，得到描边

#### color blocks.色块

想要亮灰暗部分界限分明，进行取整操作，以高光为例,如果一些值值超过了1.5,则认为全是1.5，没超过但大于0的,我们认为全都是0.8,而那些本来就是0的依旧是0.

#### Stroke surface stylization素描风格

* 设计不同线条密度的纹理
* 对于不同明暗的纹理使用不同的纹理

# 第12章 Real - Time Ray Tracing

#### temporal accumulation 时间累计——时间降噪

当前帧需要降噪，根据motion vector，复用上一帧降噪结果，这叫做时间（帧）上的复用

找到当前帧i某像素，在上一帧i-1的位置

* 当前帧世界坐标：如果G-buffer中有世界坐标，可以拿来即用，如果没有需要计算，应用矩阵逆变换来得到
* 上一帧的世界坐标：由于知道所有移动信息，可以找到i-1帧物体的世界坐标，
* i-1的像素位置：应用变换

这样就获得了motion vector

i和i-1帧线性混合：上一帧*a + 当前帧\*（1-a）




















在每一个新的帧i渲染时，渲染器会根据之前帧 < i 的信息，并将当前帧的渲染数据与这些历史信息进行加权平均（衰减式的加权），会随着时间增加使画面越来越清晰

**找到上一帧信息**

想要获取上一帧i的信息，就需要知道上一帧i-1对应在哪个像素上，也就是uv(i)->world(i)->world(i-1)->uv(i-1)，

![1742030852103](/assets/img/blog/Games202/世界坐标.png)

要获得世界坐标s，需要当前uv坐标x与MVP和E视口矩阵的逆矩阵相乘

![1742030991222](/assets/img/blog/Games202/上一帧位置.png)

要获得上一帧的世界坐标s·，就需要让当前世界坐标s 乘以T变换（Model部分 / motion vector）的逆矩阵

找到当前像素在上一帧对应物体，在当前画面中对应的像素位置，motion vector和相机运动方向是相反的

![1742031205373](/assets/img/blog/Games202/uv坐标.png)

要获得上一帧的uv坐标x·，需要s·乘以EPVM

**混合**

![1742035664903](/assets/img/blog/Games202/混合.png)

在找到上一帧的信息后就可以加权混合，第一个公式按空间混合，第二个按时间线性混合，其中~ : unfiltered 表示没有filter的内容，- : filtered 表示已经filter的内容，a 表示平衡系数，即当前帧的贡献

**一些问题**

* 突然切换了场景 / 缩放相机（场景变多）/ 相机位移，没有上一帧信息，
* 切换了光源颜色，就不能再用上一帧的信息了，否则颜色不正确，

![1742038651359](/assets/img/blog/Games202/拖尾.png)

* 上一帧权重超过0.8时 / 光源移动场景不移动 会造成拖尾，
  * 比如2这里，很大部分保留了上一帧柜子的颜色和自身墙面颜色混合，所以呈现绿色（camera向左移动，物体相对相机右移，因此查询方向是向右的），
  * 对于1这里，保留了之前所有帧不同权重的混合，因此接近于白色，
  * 对于绿条中间夹杂的白色是柜子两侧的边框，因为和墙面差不多颜色，没有明显拖尾现象

对于拖尾情况，有两种解决方法：

* clamping限制：把上一帧结果限制到当前结果的近似，再混合
* detection检测：当在世界找到i-1的位置时，判断它们是否是同一个物体id，如果id不同，a就不再用0.8而是其他百分比混合
