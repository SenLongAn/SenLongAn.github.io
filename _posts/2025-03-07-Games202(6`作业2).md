---
title: Games202(6·作业2)
date: 2025-03-07 12:00:00 +0800
categories: [Games202]
tags: [实时渲染]     # TAG names should always be lowercase
math: true
---
# 作业2

#### 框架说明

框架包含两部分，nori的预计算部分，和webgl渲染部分

nori工程是一个开源的用C++编写的简单的教学光线跟踪器，在源码框架下，加入了prt.cpp文件

#### 编译nori项目

steps：

* 首先进入nori工程
* mkdir创建目录，以便用于存放构建文件，
* 进入目录后cmake命令根据CMakeLists.txt 文件（描述项目的构建规则），生成构建文件（例如sln等项目文件）
* make命令编译链接项目
* 运行可执行文件（参数为xml文件）： ./Debug/nori.exe  ../scenes/prt.xml 

**Error1：**

*** No targets specified and no makefile found.  Stop.

当在make命令时会出现这个错误，因为使用的vs2019及以上的版本时，cmake .. 调用的时vs自带的编译器MSVC， 它是没办法用mingw的make的

解决方式是用vs打开nori.sln编译链接生成nori.exe

**Error2：**

<lambda_9ed74708f63acbd4deb1a7dc36ea3ac3>::operator()

因为MSVC 对于代码中的中文字符支持有问题（应该是会吞换行符），需要启用 utf-8 编译选项，在 prt/CMakeLists.txt 112 行添加：

target_compile_options(nori PUBLIC /utf-8) # MSVC unicode support

**解析prt.xml文件**

这里面定义了程序运行需要的一些参数

type表示漫反射传输项类型，bounce代表反弹次数，PRTSampleCount蒙特卡洛的采样数量，cubemap代表 cubemap的目录存储了六张贴图

**运行（可视法线）**

![1741346335513](/assets/img/blog/Games202/编译.png)

#### 解析

* 预计算存储的L和LT数据以txt文件保存，在engin.js实现了读取分割并保存为Array的算法，它将数据储存在了两个全局变量precomputeL、precomputeLT数组中
* PRTIntegrator::Li（const Scene *scene, Sampler *sampler, const Ray3fray）实现了可视化球谐系数结果的方法
  
#### 预计算 L sh系数

将在prt.cpp中的ProjEnv::PrecomputeCubemapSH()函数实现

![1741346328376](/assets/img/blog/Games202/解方程.png)

想要使用球谐函数来表示环境光，就需要将环境光投影到球谐函数上来得到对应的系数，通过黎曼积分求和计算结果

**代码解析**

prt.cpp中包含了下面的函数

* CalcArea(u,v,width,height)来计算cubemap上每个像素所代表的矩形区域投影到单位球面的面积（立体角）

PrecomputeCubemapSH函数

* 首先创建cubemapDirs[]数组，计算cubemap的6张贴图上每个像素对应的单位方向向量，存储在里面
* 仍通过3重嵌套循环每个像素，
  * 首先获取到像素方向 dir = cubemapDirs[i * width * height + y * width + x],即（前i个像素总量 + y的高度行数 * 像素宽度个 + x的宽度列数）
  * index根据xy找到在image环境贴图中的索引
  * Le环境光，在2维数组中，第i个贴图，index的位置，找到像素对应的环境光值
  * delta_w根据CalcArea求得像素的立体角
  * 获取基函数basic_sh_proj：利用EvalSH函数求得sh在某方向的基函数m（范围-l -- l，因为l层有2l + 1个基函数），SHOrder表示sh的阶数
  * 通过GetIndex获取基函数在一维下的索引，并利用黎曼积分公式求得此基函数对应的系数


#### 预计算 diffuse unshadowed LT sh系数

对于无阴影来说，LT部分仅包含 Mdu=max(Nx·ωi,0)，同L部分一样，想要使用sh来表示LT，就需要将LT投影到sh上来得到对应的系数

因为是采样求和，会考虑n_samples次，每次计算Mdu值，如果>0说明射线在半球上从而考虑它，

循环n_coeff系数次，把Mdu投影到sh上，获得本次result，乘以(权重/采样数)获得系数

**代码实现**

应在PRTIntegrator::preprocess(const Scene *scene)实现预计算，

环境光系数保存在m_LightCoeffs中，预计算得到的传输项系数保存在m_TransportSHCoeffs中

#### 预计算 diffuse shadowed LT sh系数

有阴影的LT部分和无阴影的部分几乎一致，但要考虑V项，Mdu = V(ωi)max(Nx·ωi,0)

在算法中，多加入if判断当前射线是否和其他物体相交，如果没有相交，说明未被遮挡，即光源可以照射到因此并非阴影，考虑接下来的计算

#### 预计算 diffuse inter-reflection LT sh系数

LDI = LDS +  ρ/π  积分 L^(x′, ωi) (1−V(ωi)) max(Nx·ωi,0)dωi

首先每个p点计算lds直接光照部分，如果p点发射的光线有交点，则在交点处求出重心坐标插值后的球谐系数，这个系数就表示间接光照的球谐系数

#### 实时球谐光照计算

完成了预计算部分，就是计算了环境光，要渲染出来，首先要新建材质，编写对应的shader

**注意：**

框架nori部分，用cmake构建后，light.txt(光照球谐系数数据)和transport.txt（传输线球谐系数数据）两个文件（在prt/scenes/cubemap/indoor/中）拷贝到webgl部分的（assets/cubemap/indoor/中）

#### 环境光球谐旋转

我们将使用简单的低阶SH快速旋转方法，以便在旋转环境光时旋转sh，以便使得环境光和模型仍能够正确交互

R(f(x))=f(R(x))对原函数f(x)的旋转R(f(x))与直接旋转f(x)的自变量是一样的