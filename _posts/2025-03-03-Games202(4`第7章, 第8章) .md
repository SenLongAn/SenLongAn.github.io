---
title: Games202(4·第7章，第8章)
date: 2025-03-03 12:00:00 +0800
categories: [Games202]
tags: [实时渲染]     # TAG names should always be lowercase
math: true
---
# 第7章

#### PRT预计算辐射传输

渲染方程 = ∫ L F cos V阴影可视项 d

PRT的核心思想是利用sh函数……预计算，以便加快运行计算速度

ptr将渲染方程分为两部分：light光照： L 和 light transport光照传输： FVcos

重要定理：两个函数的product integral乘积积分 ≈ 两个函数积分的乘积

**Diffuse**

![1740961941876](/assets/img/blog/Games202/渲染方程_漫反射.png)

漫反射F项为常数，因此可以提取出来，L项用sh函数表示（投影这一步L(θ，φ)根据环境贴图方向向量采样求得），li系数提取到积分外，light transport项作为系数，Bi作为基函数，这是投影操作（V(θ，φ)从光源反射方向发射射线，如果和场景有交点则说明被遮挡，否则未被遮挡，cos项已知p点法线和采样方向可以求解），获得浮点值，转换为LT点乘求和

由于预计算light transport项，因此V不能变化，也就是只适用于静止场景

![1740961957711](/assets/img/blog/Games202/渲染方程_漫反射2.png)

另一种表示方式，把light项和light transport项，都sh重建，(∫  (Σ L_i\*Y_i(ω))  (Σ T_j*Y_j(ω)) )，由于前面有积分，因此Lo ≈ Σ_i Σ_j L_i T_j ∫ Y_i(ω) Y_j(ω) dω,即嵌套求和

复杂度为n^2，n为项数量，由于标准正交性（当 i = j 时为 1，否则为 0），因此只有对角线上有值，因此复杂度为n

**Specular**

p项并非常量，不可以提取到积分外,且依赖于视角v==o

![1740961981775](/assets/img/blog/Games202/渲染方程_镜面反射.png)

light transport项用sh重建（系数：Vcos项和上面一样求解，对于F(θ，φ)依赖于wi、wo，就像wi一样可以离散采样wo，预生成二维数据），由于light transport项依赖于(ω_i(θ，φ), ω_o(θ，φ))，投影得到系数不在是一维的（仅依赖wi），变为二维（wi，wo），这会产生巨大的存储和花费更多预计算时间

以4阶为例，共16项，对于漫反射，L项16个系数 * LT项16个系数，对于镜面反射，L项16个系数 * LT项16*16个系数矩阵

#### RSM反射阴影贴图

首先计算直接光照，间接光照采用以下计算方式：

**哪些作为VPL**

将所有被光源直接照亮的点作为VPL次级光源，可以使用shadow map，它每一个像素作为一个VPL

**假设**

假设所有的VPL都是diffuse的，为了不依赖于观察方向v

**贡献值**

![1740986475703](/assets/img/blog/Games202/光源采样.png)

一个VPL即q对p的贡献值：（使用的光线追踪向光源有偏采样的思想）

由于VPL实际很小，我们通常不用积分，直接把它当作一个点q

![1740987434876](/assets/img/blog/Games202/值.png)

由于假设条件，因此fr是常数，可以提取到积分外

VPL接收的能量E在pq方向出射的辐射率：fr * φ/dA（辐射照度E），作为对p点的贡献能量li

![1740987283308](/assets/img/blog/Games202/p对q贡献值.png)

把li带入渲染方程，dA会抵消掉，将剩余的φ和cos项组合为EP

这样EP与剩余部分（F，V）结合，求得一个VPL对p点着色结果

对于V项如何求？常规思路是为每个次级光源按照pq方向算一次shadow map，比较深度值和pq的距离，但这样复杂度太高了，也没有什么好的方法，因此忽略V项

对所有VPL进行上述计算，获得最终的p间接光照结果

**贡献权重**

每个p点（shadow map所有像素）和每个VPL做上述计算，复杂度太高了

实际上并非所有VPL都会对p有贡献，比如V中间有阻挡物，pq方向在p的法向半球下，距离太远

因此为了加速这一过程，将p投影到shadow map上，从它的附近采样VPL，采样点离投影位置越近越多

往外采样数越少可能会带来的问题，引入权重值，越近权重越小，越远权重越大

**数据存储**

在shadow map每一个像素中都需要存储VPL的相关信息比如：深度值，世界坐标，法线，反射光功率

# 第8章

#### LPV光传播体积

它快速且高质量

steps步骤：

* 首先计算直接光照，间接光照采用以下计算方式：
  * 划分（将场景划分为若干个3D网格,每个网格叫做Voxel体素）
  * 生成（同RSM一样利用Shadow Map找到所有VPL，可以进行采样简化光源数量）
  * 注入（将VPL注入到3D网格，一个格子内可能包含许多不同朝向的VPL，把它们合并得到总VPL，可以看作球面函数用sh表示（通常用2阶也就是n==4个项））
  * 传播（迭代网格中传播radiance，分为6个(上下左右前后)可能方向，不考虑倾斜）
  * 渲染（找到p对应的网格，获得所有的radiance，对p点渲染）

问题：

漏光：不应该被照亮的地方被照亮，解决方法是将网格划分较小，但是导致计算速度慢

Cascade层级加速结构可以优化LPV性能

#### VXGI体素全局光照

steps：

首先计算直接光照，间接光照采用以下计算方式：

* light pass: 
  * 划分（将场景划分为若干个3D网格,每个网格叫做Voxel体素）
  * 生成（同RSM一样利用Shadow Map找到所有VPL，可以进行采样简化光源数量）
  * 注入（不同于LPV的合并，通过表面材质来准确的算出出射的分布，因此可以支持glossy的LPV，并且比LPV更准确）
* camera pass:
  * 传播(从相机向每个pixel方向发出ray，根据交点材质获得反射方向，如果是glossy（diffuse和specular之间）打出一个锥形区域，diffuse打出若干个锥形区域)
  * 渲染（锥形按照空间层级查询，如果与voxel相交，则将它对p的贡献算出来）

#### SSAO屏幕空间环境遮蔽

详见其他章节