---
title: c++(7`数据大小、内存管理和分配)
date: 2025-04-01 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---
# 数据大小

![1743508607402](/assets/img/blog/c++/数据类型的大小.png)

![1743579107423](/assets/img/blog/c++/不同位系统.png)

![1743660760999](/assets/img/blog/c++/指针大小.png)

不同位系统，long和指针的字节数可能不同

# 内存五大分区

![1745026926690](/assets/img/blog/c++/内存分区.png)

1. 内核空间：是系统内部的区域，不可直接读写
2. 堆区：存放动态生命周期对象，完全由程序员控制
   1. 效率较低：由于new/delete会造成内存空间不连续，使程序效率降低（寻址），堆的机制是很复杂的，它比栈的效率要低
   2. 空间大：对于32位系统，可达2^32 = 4G
3. 栈区：存储自动生命周期对象
   1. 效率高：执行效率很高
   2. 空间小：大约只有2MB
4. 静态区/数据段：存储静态生命周期对象，分为BSS段（未初始化的）和DATA段（已初始化的）
5. 常量区/代码段：存储程序指令、函数编译后的可执行的二进制代码、只读常量，也是静态生命周期对象

# size_t

size_t是一种数据类型，是和平台相关的无符号整数类型，在32位系统上，是4字节，在64位系统上，是8字节

使用场景：表示字节数量（sizeof），对象数量（size，strlen）

优点：有跨平台优势

```c++
const size_t huge_size = sizeof(……); //内存大小
int arr[5000000000];//对象数量
for (size_t i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) { //循环计数
}
```

假设是32位CPU，size_t表示的范围是2^32 == 0——4294967295（索引）

按字编址，地址总线的位数是32，即寻址范围共2^32字节 == 4,294,967,296 字节（个数） == 4G

一个对象字节数不可超过4,294,967,296，size_t恰好可以表示

而一个对象最小为一字节，显然最多不会超过4,294,967,296个

# sizeof

```c++
size_t arrLength = sizeof(arr) / sizeof(arr[0]); 
```

sizeof()是运算符：

* 以类型，变量，表达式求值结果，函数作为参数
* 返回字节大小
* 编译时计算
* 当用sizeof计算C风格字符串长度时，返回的长度大小包括’\0’终止符
* 基本数据类型，long在32位占4字节，64位占8字节
* 复合类型，指针在32位占4字节，64位占8字节，数组 元素类型字节数 * 元素数量

```c++
// 对齐访问：单次内存操作
┌───┬───┬───┬───┐
│ B │ B │ B │ B │  // 一次读取4字节
└───┴───┴───┴───┘

// 非对齐访问：需要多次操作
┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐
│   │ B │ B │ B │ │ B │   │   │   │  // 两次读取+数据拼接
└───┴───┴───┴───┘ └───┴───┴───┴───┘

// 情况A：非对齐紧凑排列
地址: 0x1001 0x1002 0x1003 0x1004 | 0x1005 0x1006 0x1007 0x1008 | 0x1009 0x100A 0x100B 0x100C
读取第一个int: 需要访问0x1000-0x1003和0x1004-0x1007两个内存块
读取第二个int: 需要访问0x1004-0x1007和0x1008-0x100B两个内存块  
读取第三个int: 需要访问0x1008-0x100B和0x100C-0x100F两个内存块
总内存访问: 6次

// 情况B：对齐排列（有填充）
地址: 0x1000 0x1001 0x1002 0x1003 | [填充] | 0x1008 0x1009 0x100A 0x100B | [填充] | 0x1010 0x1011 0x1012 0x1013
读取第一个int: 只需访问0x1000-0x1003（1次）
读取第二个int: 只需访问0x1008-0x100B（1次）
读取第三个int: 只需访问0x1010-0x1013（1次）  
总内存访问: 3次
```

* 内存对齐：
  * 是指数据在内存中的存储地址必须是某个值的整数倍,而不是一个接一个地存放，32位CPU：通常4字节对齐，64位CPU：通常8字节对齐
  * 字长决定一次寻址的大小，如果数据非内存对齐，就需要多次寻址，降低效率
* 自定义类型

  ```c++
  struct stru  
  {   
    char i;  //start address is 0 
    int m;   //start address is 4
    char n;  //start address is 8
  }; 
  //sizeof(stu) 12

  //嵌套结构体
  struct stru1  //被展开的结构体
  {  
    short i;  //start address is 0 
    struct   //展开后的结构体
    {  
        char c;  //start address is 4
        int j;  //start address is 8
    } tt;   
    int k;  //start address is 12
  };
  //sizeof(stru1) 16

  //结构体包含数组
  struct array  
  {  
    float f;  //start address is 0 
    char p;  //start address is 4
    int  arr[3];  //start address is 8
  };
  //sizeof(array) 20
  ```

  * 类
    * 对齐原则：
      * 偏移量：成员地址相对结构体地址的偏移，成员偏移量 == 上一个成员偏移量 + 上一个成员大小
      * 结构体大小等于最后一个成员的偏移量加上最后一个成员的大小，第一个成员的偏移量是0，当前成员偏移量必须是当前成员类型的整数倍（内存对齐）
      * 最后结构体也要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍
    * 嵌套结构体
      * 展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍
      * 结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体
    * 结构体包含数组
      * 和处理嵌套结构体一样

# strlen

```c++
char str[] = "Hello, World!";
size_t length = strlen(str); 
```

strlen(…)是函数，

* strlen(const char* str) ，参数为“……” C风格字符串，
* 返回的长度大小不包括’\0’终止符，
* 运行时计算
* 参数必须是字符型指针（char*）
* 用于返回字符串的实际长度

```c++
void Test1()
{
	char p[] = "hello";//5,6
	cout << "p: " << p << "   " << strlen(p) << "   " << sizeof(p) << endl;
	char p1[] = "hello\0";//5,7，‘\0’是一个char
	cout << "p1: " << p1 << "   " << strlen(p1) << "   " << sizeof(p1) << endl;
	char p2[] = "hello\\0";//7,8,第一个\是转义\0的，所以它不算字符，它会让后面的\0变为普通的字符
	cout << "p2: " << p2 << "   " << strlen(p2) << "   " << sizeof(p2) << endl;
	char p3[] = "hello\\\0";//6，8，第一个\只转义了第二个\，使得第二个\不能再转义后面
	cout << "p3: " << p3 << "   " << strlen(p3) << "   " << sizeof(p3) << endl;
	char p4[] = "hel\0lo";//3，7
	cout << "p4: " << p4 << "   " << strlen(p4) << "   " << sizeof(p4) << endl;
	char p5[] = "hel\\0lo";//7，8
	cout << "p5: " << p5 << "   " << strlen(p5) << "   " << sizeof(p5) << endl;
}
```

注意：strlen 计算的是字符串的实际长度，遇到\0（空字符）即停止；sizeof 计算整个字符串所占内存字节数的大小，当然\0也要+1计算

# memcpy

按字节内存拷贝（memory copy），仅支持POD类型

void *memcpy(void *str1, const void *str2, size_t n)

从str2所指向的内存区域复制n个字节到str1所指向的内存区域

num：

* num < src大小	 数据不完整，但安全
* num > src大小	 读取越界，未定义行为
* num < desc大小	正常拷贝，有剩余空间
* num > desc大小	缓冲区溢出，可能崩溃

当拷贝C风格字符串，需要strlen+1 / sizeof，否则不包含\0,在使用字符串时将出现错误

使用场景：快速将 基本数据类型/数组/POD结构体/C风格字符串/内存块 复制

# memset

void *memset(void *str, int c, size_t n)

将一段内存区域设置为指定的值，通常用于初始化数组或结构体，它按字节赋值

将str所指向的内存区域的前n个字节，设置为c

由于按字节赋值，常用的c值：0/-1（结果和c值一样），0x3f设置为无穷大

使用场景：将数组/POD结构体 初始化为0/1/无穷大

# allocator

```c++
#include <memory>
std::allocator<int> alloc;
int* ptr = alloc.allocate(5);  // 分配5个int的空间
for (int i = 0; i < 5; i++) {// 在指定位置构造对象
    alloc.construct(ptr + i, i * 10);  
}
for (int i = 0; i < 5; i++) {// 销毁对象（不释放内存）
    alloc.destroy(ptr + i);
}
alloc.deallocate(ptr, 5);// 释放内存

MyClass* memory = alloc.allocate(1);
alloc.construct(memory, MyClass());
```

分配器类模板:提供高级管理内存的方式，将内存分配和构造分离开来

# malloc、free、calloc、realloc

```c++
void* malloc(size_t size);
int* p = (int*)malloc(40);

void* memory = malloc(sizeof(MyClass));
MyClass* obj = new(memory) MyClass(42, "hello");//定位new
```

malloc：C 风格内存分配，在堆上，如果开辟成功，则返回内存指针，如果失败，返回nullptr指针

参数是字节数量，返回无类型的指针

在使用时应强制转换为具体类型

普通new：内存分配和构造，绑定在一起

定位new：不会分配新内存，它只是在已经存在的内存地址上调用构造函数

```c++
void free (void* ptr);
free(p);//避免内存泄漏
p = NULL;//避免空悬指针
```

需要用free释放内存，参数是指针，指向的必须要是动态分配的内存

```c++
void* calloc(size_t num, size_t size);
```

calloc：为num个size字节的元素开辟一块空间，并且把空间的每个字节初始化为0

```c++
void* realloc(void* ptr, size_t size);
```

realloc: 对动态开辟内存大小的调整,ptr指向被调整的旧内存起始地址，size调整后的新大小，返回调整后的新内存起始地址

原有空间之后有足够空间开辟新空间，那么紧挨着开辟，并返回旧地址

原有空间之后没有足够空间开辟新空间，那么开辟新的空间，拷贝数据，释放旧空间，返回新地址
