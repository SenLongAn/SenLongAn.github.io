---
title: c++(7`数据大小、内存大小和计算)
date: 2025-04-01 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---
# 数据类型的大小

![1743508607402](/assets/img/blog/c++/数据类型的大小.png)

长度的单位为字节，右边是可表示的十进制数字范围

![1743579107423](/assets/img/blog/c++/不同位系统.png)

![1743660760999](/assets/img/blog/c++/指针大小.png)

不同位系统，long和指针的字节数可能不同

# 内存五大分区

![1745026926690](/assets/img/blog/c++/内存分区.png)

1. 内核空间：存放操作系统内核代码、内核数据（如进程调度、内存管理……），是不可直接读写的
2. 堆区：存储由程序员动态分配（new/malloc/智能指针……）的对象，存放对象的生命周期是动态的
   1. 由于new/delete并不会遵守堆的先进先出的特性，会造成内存碎片，使程序效率降低（寻址）
   2. 空间大：对于32位系统，可达2^32，但是仍要保持清理内存，否则访问越界会造成程序崩溃
   3. 堆的机制是很复杂的，它比栈的效率要低
3. 栈区：存储局部对象，它们的生命周期是自动的
   1. 先进后出的结构，不会造成内存碎片
   2. 容量小：大约只有2MB
   3. 执行效率很高
4. 静态区/数据段：存储全局变量，静态变量，它们的生命周期是静态的
5. 常量区/代码段：存储程序指令、函数编译后的可执行的二进制代码、只读常量，它们的生命周期是也是静态的，但它们是只读的不能修改

注意： 指针变量本身是存放在栈区的，而指针所指向的对象可以位于栈区、堆区或者全局/静态存储区，它是根据对象本身决定的

# size_t

size_t 是一种平台相关的无符号整数类型，足够容纳 任何内存大小/对象数量 的表示，在32位系统上，它通常是4字节的unsigned int；而在64位系统上，它通常是8字节的 unsigned long

_32 位和 64 位指的是CPU（处理器）的字长，字长是CPU在一次计算中能处理的二进制数据的最大位数，它决定了数据处理速度、寻址范围（通常地址总线位数和字长一致）_

```c++
const size_t huge_size = sizeof(……); //内存大小
int arr[5000000000];//对象数量
for (size_t i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) { //循环计数
}
```

为什么足够容纳 任何内存大小/对象数量 的表示？

假设是32位CPU，size_t表示的范围是0——4294967295

按字编址，地址总线的位数是32，即寻址范围共2^32字节 == 4,294,967,296 字节 == 4G

也就是说一个对象最大的sizeof值不会超过4,294,967,296，size_t恰好可以存储

而一个对象最小为一字节，显然最多不会超过4,294,967,296个

作用：

* 表示内存大小/对象数量
* 用于循环计数，避免因使用 int 而可能导致的溢出问题

# sizeof

```c++
int *arr = (int *)malloc(n * sizeof(int)); 
size_t personSize = sizeof(struct Person); 
size_t arrLength = sizeof(arr) / sizeof(arr[0]); 
```

sizeof()是运算符：

* 以类型，变量，表达式求值结果，函数作为参数，返回对象的字节大小
* 编译时计算
* 当用sizeof计算C风格字符串长度时，返回的长度大小包括’\0’终止符
* 基本数据类型，long在32位占4字节，64位占8字节
* 复合类型，指针在32位占4字节，64位占8字节，数组 元素类型字节数 * 元素数量
* 内存对齐：内存空间按照字节划分，但不同硬件平台对存储空间的处理上存在很大的不同，
  * 某些平台对特定类型的数据只能从特定地址开始存取，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，否则会触发异常
  * 更常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失
  * 总线宽度：单次能传输的数据位数，32位通常为32位，64位通常为64位
  * 比如总线宽度为32位，如果一个32位的数据没有存放在4字节整除的内存地址处（即被32位），那么处理器就需要2个总线周期对其进行访问，访问两次4字节，而之前只需要访问1次4字节
* 自定义类型

  ```c++
  struct stru  
  {   
    char i;  //start address is 0 
    int m;   //start address is 4
    char n;  //start address is 8
  }; 
  //sizeof(stu) 12

  //嵌套结构体
  struct stru1  //被展开的结构体
  {  
    short i;  //start address is 0 
    struct   //展开后的结构体
    {  
        char c;  //start address is 4
        int j;  //start address is 8
    } tt;   
    int k;  //start address is 12
  };
  //sizeof(stru1) 16

  //结构体包含数组
  struct array  
  {  
    float f;  //start address is 0 
    char p;  //start address is 4
    int  arr[3];  //start address is 8
  };
  //sizeof(array) 20
  ```

  * 类
    * 对齐原则：
      * 偏移量：成员地址相对结构体地址的偏移，成员偏移量 == 上一个成员偏移量 + 上一个成员大小，结构体大小等于最后一个成员的偏移量加上最后一个成员的大小，第一个成员的偏移量是0，其后成员偏移量必须是当前成员类型的整数倍
      * 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍
    * 嵌套结构体
      * 展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍
      * 结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体
    * 结构体包含数组
      * 和处理嵌套结构体一样

# strlen

```c++
char str[] = "Hello, World!";
size_t length = strlen(str); 
```

strlen(…)是函数，

* strlen(const char* str) ，参数为“……” C风格字符串，
* 返回的长度大小不包括’\0’终止符，运行时计算
* 要在运行时 才能计算。参数必须是字符型指针（char*）
* 一般用于返回**字符串的实际长度**

```c++
void Test1()
{
	char p[] = "hello";//5,6
	cout << "p: " << p << "   " << strlen(p) << "   " << sizeof(p) << endl;
	char p1[] = "hello\0";//5,7
	cout << "p1: " << p1 << "   " << strlen(p1) << "   " << sizeof(p1) << endl;
	char p2[] = "hello\\0";//7,8,第一个\是转义\0的，所以它不算字符，它会让后面的\0变为普通的字符
	cout << "p2: " << p2 << "   " << strlen(p2) << "   " << sizeof(p2) << endl;
	char p3[] = "hello\\\0";//6，8，第一个\只转义了第二个\，使得第二个\不能再转义后面
	cout << "p3: " << p3 << "   " << strlen(p3) << "   " << sizeof(p3) << endl;
	char p4[] = "hel\0lo";//3，7
	cout << "p4: " << p4 << "   " << strlen(p4) << "   " << sizeof(p4) << endl;
	char p5[] = "hel\\0lo";//7，8
	cout << "p5: " << p5 << "   " << strlen(p5) << "   " << sizeof(p5) << endl;
}
```

注意：strlen 计算的是字符串的实际长度，遇到\0（空字符）即停止；sizeof 计算整个字符串所占内存字节数的大小，当然\0也要+1计算

# memcpy

按字节内存拷贝（memory copy），无需通过for循环拷贝了

void * memcpy ( void * destination, const void * source, size_t num );

* 目标数组（复制到这里）
* 源数组（从这里复制数据）
* 字节数

```c++
int arr1[10] = { 1,2,3,4,5,6,7 };
int arr2[10] = { 0 };
memcpy(arr2, arr1, 7 * 4);//arr2 : 1,2,3,4,5,6,7
int arr1[10] = { 1,2,3,4,5,6,7 };//1,2,3,4,5,6,7,0,0,0
int arr2[10] = { 0 };
memcpy(arr2, arr1 + 3, 7 * 4);//arr2 : 4,5,6,7,0,0,0,会跳过前3个元素,复制后面的7个元素
```

如果src不足num个，它会导致读取未初始的内存，如果des不足num个，会导致缓冲区溢出

# malloc、free、calloc、realloc

```c++
void* malloc(size_t size);//参数是字节数量，返回无类型的指针
int* p = (int*)malloc(40);//分配40个字节空间，强制转换为int，相当于int arr[10];
```

malloc（memory allocation内存分配）：C 风格内存分配，如果开辟成功，则返回内存指针，如果失败，返回nullptr指针，

```c++
void free (void* ptr);//ptr必须要是动态分配的
free(p);//避免内存泄漏
p = NULL;//避免空悬指针
```

需要用free释放内存

```c++
void* calloc(size_t num, size_t size);
```

calloc(contiguous allocation动态内存分配并清零)：为 num个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0

```c++
void* realloc(void* ptr, size_t size);//
```

realloc: 对动态开辟内存大小的调整,ptr指向被调整的旧内存起始地址，size调整后的新大小，返回调整后的新内存起始地址
