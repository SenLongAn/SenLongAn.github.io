---
title: C++ 合成的默认成员函数、虚继承
date: 2025-06-26 12:00:00 +0800
categories: [C++]
tags: []
math: true
---

# 合成的默认成员函数

## 架构

![alt text](/assets/img/blog/c++/成员函数架构.png)

类成员函数分为特殊成员函数、普通成员函数，特殊成员函数包括默认……函数、自定义……函数，默认……函数包括合成默认……函数、自定义默认……函数

类定义中的类成员均属于声明而非定义，定义是发生在类对象创建时

当一个函数只有声明没有定义，不允许被调用

合成：编译器自动生成（即生成public inline函数）

默认：特殊成员函数的最基本形式

### 合成的默认构造

* 默认构造函数：可以不用实参进行调用的构造函数，包括没有显示形参列表 / 提供默认实参的构造函数，之所以强调显示是因为，编译器总是会为构造函数形参列表插入一个隐含的this指针
* 能否重载：能
* 能否声明为虚函数：构造函数不能声明为虚函数
  * 构造函数声明为虚函数会产生虚表，虚表指针，虚构造函数存放在虚表中，需通过虚表指针访问
  * 虚表指针在构造函数内初始化，即指向虚表
  * 因此虚构造函数无法访问
* 合成默认构造函数的合成条件：
  * 当没有自定义构造函数时，且需要触发以下条件：
    * 含有类对象数据成员，且该类对象有默认构造函数
    * 类派生自一个含有默认构造函数的基类时
    * 类包含虚函数：本身定义的 / 继承重写的
    * 带有虚继承的类

```c++
derived d;
derived* d = new derived();
base* b = new derived();
```

* 构造函数调用时机：定义类对象/new分配时自动调用
* 默认构造函数调用时机：定义类对象/new分配时没有显示初始化（即使用默认初始化方式）
* 合成默认构造函数的合成时机： 构造函数需要被调用的时候才会开始合成

  ```c++
  //自定义构造函数
  MyClass(int x, int y, int z) : a(x), b(y)……{//成员初始化列表
      c = z;//函数体赋值
  }
  ```

* 调用构造函数具体顺序，和类成员初始化方式：
  * 定义类对象/new分配
  * 按照类定义中的声明顺序，为所有类成员分配内存空间
  * 如果使用直接初始化方式定义的（有实参列表）
    * 如果有匹配的自定义构造函数
      * 则调用自定义的构造函数
        * **成员初始化列表初始化**
          * 如果在列表中，实参值会覆盖**类内初始值**，内置变量支持3种显示初始化方式、类成员对象支持3种显示初始化方式
          * 如果未在列表中，如果存在类内初始值使用它，否则**隐式初始化**：
            * 如果在全局作用域下，内置变量初始0、类成员对象调用默认构造函数
            * 否则，内置变量未定义、类成员对象调用默认构造函数
        * 调用构造函数体
          * **函数体内赋值**：如果有赋值操作，进行赋值
          * 其他操作指令……
    * 如果没有匹配的自定义构造函数
      * 发生错误
  * 如果使用默认初始化方式定义的（无实参列表）
    * 如果有自定义的默认构造函数
      * 则调用自定义的默认构造函数
        * 对类成员初始化
          * 如果存在类内初始值使用它，否则：
            * 如果在全局作用域下，内置变量初始0、类成员对象调用默认构造函数
            * 否则，内置变量未定义、类成员对象调用默认构造函数
        * 调用构造函数体
          * 如果有赋值操作，进行赋值
          * 其他操作指令……
    * 如果没有自定义的默认构造函数
      * 如果合成条件成立，合成默认构造函数
        * 对类成员初始化
          * 如果存在类内初始值使用它，否则：
            * 如果在全局作用域下，内置变量初始0、类成员对象调用默认构造函数
            * 否则，内置变量未定义、类成员对象调用默认构造函数
      * 否则合成条件失败，发生错误  <<---
* 哪些成员必须通过成员初始化列表进行初始化：
  * 常量成员变量，虽然允许类内初始值，但C++语法要求必须通过成员初始化列表进行初始化，隐式初始化会产生未定值/0，由于不能被赋值，也就不能在函数体内赋值
  * 引用类型成员变量，同上
  * 没有默认构造函数的类类型成员, 必须显示调用有参构造函数，否则会执行默认初始化，走到上述标记处 <<--- 引发错误
  * 继承体系中基类构造函数
    * 不能在其他地方调用：基类构造函数仅能在派生类初始化列表中调用，我们也不能直接初始化基类的成员
    * 必须显示/隐式调用：派生类必须 显示的在其初始化列表中调用基类的构造函数 / 隐式调用基类的默认构造函数，如果基类没有构造函数，将编译失败，只有调用了基类的构造函数，才能初始化基类部分
* 成员变量的初始化顺序：与它们在类定义中的声明顺序相同，而不是它们在初始化列表中出现的顺序
* 静态变量不能出现在列表中，因为它不属于具体类对象，它必须在类外显示定义和初始化
* 继承体系中构造函数调用顺序是递归的
  * 调用顺序：派生类 -> 直接基类 -> 间接基类
  * 执行顺序：间接基类 -> 直接基类 -> 派生类

### 合成的默认析构

* 析构函数合成条件：
  * 当未自定义构造函数时：
    * 且基类和成员变量均有可访问的析构函数
* 能否重载：不能像构造函数一样重载，一个类仅有一个析构函数
* 能否声明为虚函数：析构函数可以声明为虚函数，特别是在继承体系中，析构函数最好声明为虚函数
* 析构函数调用时机：作用域结束/调用delete清理内存时
* 继承体系中析构顺序根据定义方式决定：
  * 类对象非指针定义方式，无论是否是虚析构，都仅会调用自身的析构，因为它永远不会满足动态绑定条件
  * base* b = new base()，无论是否是虚析构，都仅会调用base的析构，因为指针对象类型和实际对象类型一致
  * base* b = new derived()
    * 调用delete时
      * 如果非虚析构，不满足动态绑定，仅会调用指针对象类型的析构函数
      * 如果是虚析构，满足动态绑定，会调用实际对象类型的析构函数，由于派生类析构隐式包含基类部分，因此完整的析构链会被调用
      * 执行顺序：派生类 -> 直接基类 -> 间接基类

### 合成的默认拷贝构造

* 

### 合成的默认拷贝赋值
### 合成的默认移动构造
### 合成的默认移动赋值

## 关键字

```c++
MyClass() = default;  // 等价于：MyClass();
MyClass(const MyClass&) = delete;
MyClass& operator=(const MyClass&) = delete;
```

private：

default：创建合成默认函数，相比于自定义默认函数，效率要高

delete：删除函数，可以对任何成员函数使用

override：

final：

# 虚继承

![alt text](/assets/img/blog/c++/菱形继承.png)

```c++
class X  { public: int i; };
class A : virtual public X{ public:int j; };
class B : virtual public X{ public:double d; };
class C : public A, public B{ public: int k; };
```

* 虚继承是一种特殊的继承机制，多重继承下确保子类对象中,每个父类只含有一个副本，即解决菱形继承问题
* 若类A虚继承于类X，则对于A来说，类X是类A的虚基类
* 虚继承会一直传递到最终派生类
