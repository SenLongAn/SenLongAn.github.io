---
title: Games202(1`前3章和作业0)
date: 2024-12-25 12:00:00 +0800
categories: [Games202]
tags: [实时渲染]     # TAG names should always be lowercase
math: true
---
# Games202_Real-Time High Ouality Rendering 实时高质量渲染

# 第一章_课程总览

* 实时软阴影
  * shadow mapping阴影贴图
  * PCSS软阴影
  * VSSM，
  * moment shadow maps，
  * SDF shadows
* 实时环境光照
  * prefiltering，
  * split sum
  * 预计算：precomputed radiance transfer
* Global Illum 预计算或无预计算的全局光照（<30fps）
  * 3D 空间：RSM
  * 3D 空间：LPV，VXGI；
  * 屏幕空间：SSAO
  * 屏幕空间：SSDO，SSR
* 基于物理的光照模型
  * 表面模型：Microfacet Model, GGX, Multiple Bounce Approximation
  * 表面模型：Disney principled BRDF；
  * 方法：LTC；
  * 杂项：NPR
* 实时光线追踪
  * backprojection，
  * motion vector，
  * temporal accumulation
  * joint bilateral filtering，
  * other denoising techs，
  * SVGF，
  * RAE
* 工业界技术
  * 抗锯齿与超采样
  * cascaded/tiled/deferred shading，
  * particles，
  * engines，
  * etc.

作业框架会使用HTML，webgl(js，glsl)还有其他的第3方库

WebGL 使得在支持 HTML 的 canvas 标签的浏览器中,可以使用openglAPI渲染，WebGL 程序包括用 JavaScript 写的控制代码，以及GPU中的glsl着色器代码

[查阅WebglAPI](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API)

本次总共有14节课程，和6个作业

# 作业框架path搭建

作业0给出了两种方法，搭建本地服务器，我们使用推荐的方法下载vscode插件_LiveServer

在我们的作业框架0，Ctrl+Shift+P调出命令行窗口，LiveServer:OpenwithLiveServer命令浏览器将自动打开指定地址的本地服务器

# 作业0代码解析

第3方库都存放在lib文件夹下面：

* dat
* imgui，轻量级用户界面库
* loader，模型加载，可以加载obj，mtl
* orbitcontrols
* three，是对webgl的封装，它的接口可以让前端程序员无需懂图形学以及背后的数学就可以完成渲染

在src文件夹下存放代码：

* lights光：EmissiveMaterial继承自 Material，使用了光的着色器，
* 点光源：仅有构造函数，包含光颜色和强度属性，网格默认是立方体，材质是EmissiveMaterial
* loads加载模型：接受一个mtl和obj的文件，创建了mesh，material，通过meshrender进行状态绑定，它会添加到指定的渲染器内
* 加载着色器：通过THREE.FileLoader()
* material材质：
  * 是个材料基类, 集中包含了我们要传给WebGl的参数，
  * 编译函数，hui返回链接的着色器
* blinn_phong材质：作业0提供的，继承自material，使用的是 blinn_phong着色器
* mesh：
  * 仅有一个构造函数，接受顶点数据和顶点索引，那么mesh中就保存了所有的信息，
  * 有一个cube的mesh，包含顶点数据，顶点索引，
* meshrender：
  * 构造函数中创建了4个缓冲，分别if检查传入的mesh中是否存在对应数据，如果存在就绑定
  * draw中：首先对相机应用MVP变换，创建了顶点数据的VAO，一系列的bind，向shader传入uniform值，通过drawElements接口绘制
* webgl渲染器：
  * 它包含了光源和网格数组，包括添加到数组的函数，
  * render函数内首先清理颜色等选项，if判断存在光源，如果存在通过嵌套for执行渲染光照数量*mesh数量次，通过mesh渲染类调用draw绘制，否则直接绘制网格
* shader：接受vs和fs，将它们编译链接为一个着色器程序
* vs和fs：没什么好说的，和正常的一样，但是它们是放在internalshader文件中作为两个const的字符串
* texture：接受图片，会为它分配内存，设置一些属性，和bind它
* engine入口点（function main()），
  * 首先获取 canvas 的引用，把它保存在‘canvas’变量里，
  * 初始化 WebGL 上下文
  * 通过THREE库初始化摄像机，和设置摄像机移动速度，大小，位置等属性
  * 为窗口添加调整窗口大小回调函数
  * 创建渲染器，光源，和加载模型和光源到渲染器中
  * 创建GUI界面，gui的参数控制mesh渲染的属性，在webgl渲染器中传入
  * 在主循环中：调用渲染
* index：
  * 我们在这里使用html语言创建画布
  * 设置画布风格
  * 链接资源文件
  * 指定使用的script路径

这里是渲染结果：

![1735971174925](/assets/img/blog/Games202/blinn_Phong.png)

# 第二章_CG基础概念

渲染流水线，opengl，glsl，渲染方程，通过类比了解它们的概念

……略

# 第三章_阴影

##### shadow mapping阴影纹理

第一次从光源位置渲染，仅需要一张深度图，第二次从摄像机方向渲染，可视点会转换到光空间，和阴影纹理比较深度值，作为是否是阴影的依据

##### 失真

自遮挡：

由于屏幕和纹理都有分辨率，因此场景中的一部分区域都会映射到同一个像素中，跟这个像素存储的深度值（中心采样点出发的）比较，当同一平面（深度相差非常小）的一个区域内，会有区域深度值 > 阴影纹理对应像素的深度值，因此会出现黑白的失真

当平面相对光倾斜角度越大，失真越明显

要解决这个失真有两种方法：

* 偏移量basic，原理是让深度变化相差不大的保持一致性，原来是>深度值的判定为阴影，现在是>深度值+basic一定偏移后的才判定为阴影
* 还有一种添加basic的方法（second-depth shadow mapping ），通过两次pass，取首次深度和次深度的中间深度，根据这个深度判定，相当于自动添加basic

悬浮：

当添加了basic后，很有可能出现悬浮问题，目前还没有什么好的解决方法

锯齿：

##### PCF(Percentage Closer Filtering)近距离过滤百分比

pcf是用来解决阴影的锯齿问题的

对于摄像机的每个像素，都去从shadowmap查找周围3*3的临近像素的深度值，取平均的结果，

##### PCSS(Percentage Closer Soft Shadow)

pcss是由pcf衍生的，当filter size很大，就可以实现软阴影

但是我们要进一步优化一下，filter size不是固定的，它需要根据**遮挡物的和阴影接收物的距离**决定filter size，当距离越远，filter应该越大，越接近于软阴影，那么filter size如何确定呢？

![1735978969942](/assets/img/blog/Games202/Pcss的filter.png)

此公式描述了filter size 过滤大小，可以想象当blocker上下移动时，filter的大小，它符合相似三角形，wlight / dblock  == wpenumbar / d(receiver - blocker)(下半部分)

首先我们要求出filter size，需要知道3个参数：

* 已知wlight，
* 需要知道dblocker光到遮挡物的距离，但是遮挡物和光都并非一个点（就比如两个平面的距离，我是以什么确定呢，以中心点还是其他？），因此需要取一定范围内的平均blocker值，即光平面的4个顶点，连线shader point的锥形体积内均可能存在block物体
* 还需要知道dreceiver光到shader point的距离（可以通过矢量减法得到）

根据公式就可以算出filter size，然后正常进行pcf即可

那么如何求在锥形体积内dblocker的平均值呢？可以查找shadowmap中的值（因为它就保存了光源到最近物体即block的距离）

![1735978995872](/assets/img/blog/Games202/确定dblock的距离.png)

但是从shadowmap的查找范围又是多大呢？

* 第一种可以简单的从shadowmap上取固定大小，如果shadowmap的像素可以遮挡住物体，判定为block，如果不能那就不是遮挡物不用考虑
* 另一种更好的方法是假设shadowmap位于light平面的近平面上，从而当光距离变化，shadowmap的采样区域也会随之变化，正好符合了视锥体的区域，对shadowmap的范围取平均……

但是可以想象到这样的方法对性能影响非常大
