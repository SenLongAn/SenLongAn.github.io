---
title: 测试与混合
date: 2025-06-23 12:00:00 +0800
categories: [OpenGL]
tags: []
math: true
---

## 深度测试

* 对片元排序，实现遮挡关系效果

## z值，深度测试，深度缓冲，深度值

* 每个顶点在几何阶段计算z值，片段使用插值z，在深度测试阶段，如果片段通过测试（常用方式z<深度值），更新深度缓冲的深度值

## 深度值为什么是非线性的

* 经过平截头体挤压和/w的共同作用下，深度值非线性，近处精度高，远处精度低（nf直接的点映射到0——1范围，通常在1/50前的距离占了0.5一半的精度，而在后面49/50的部分占了0.5一半的精度）

## 深度可视化

* 非线性深度：距离我们极近的物体有剧烈的颜色变化，而其余比这远的物体几乎呈现全白
* 线性深度：随着距离的增加有自然过渡的颜色变化

## 深度冲突

* 当没有足够精度决定极近的两个物体谁在前面时，发生深度冲突，渲染物体在两者间不断更换
* 这通常发生在远处物体（远处精度低，比如远处距离差1米的两个物体，投影到深度值后，深度值相差非常小，不在当前精度可以比较的范围）
* 解决方法
  * 不要把多个物体摆得太靠近
  * 近平面设置远一些，近处精度高，如果n后移，将对远处物体提高精度
  * 使用更高精度的深度缓冲

## 深度测试使用的是渲染流水线中那个阶段的值

* NDC空间的z值，再经过从 -1——1的值变为0——1后，它是非线性的

## 深度值的精度是指

* nf之间投射到0——1的范围，线性的是均匀投射的，非线性可能很少的距离变化就投影到了一半的0.5的深度值（0.5就是精度）
* 近处精度高，在极为解决n的位置，占了接近一半的精度
* 它和1/z成正比，和z呈反比，也就是z深度越远，精度越小，占深度值的范围越少
* 发现/z其实就是/w

## 如何获取线性深度

* 经过投影矩阵会变为非线性深度，所以我们恢复到投影前，视图坐标下的z值，这个z-n相对于f-n才是线性深度

## early-z提前/早期 深度测试（性能优化）

* 标准深度测试发生在fs后，所有物体所有覆盖的片元都要执行fs计算
* early-z发生在fs前，可以让不通过深度测试的片元不需要执行fs计算
* early-z失效
  * 开启Alpha测试
    * 假如有2个物体ab，a为完全透明，b不透明，且b在a后，预期结果为呈现b
    * 标准深度测试（在Alpha测试后）：
      * ab覆盖的片元都被fs计算，Alpha测试后a未通过丢弃，b通过保留，与预期结果相符
    * early-z（在Alpha测试前）：
      * 如果先渲染a：a通过保留，b未通过丢弃
      * 如果先渲染b：b通过保留，a通过覆盖，丢弃b
      * 总之就是丢弃后面的b，与预期结果不符合
  * 修改深度值？？
  * 开启颜色混合，通常关闭深度缓冲写入，因此early-z失效？？

## 模板测试

* 模板值通常8位，因此每个片段可以表示256个值，根据模板值，选择丢弃/保留片段
* 位掩码(Bitmask)：按位运算，改变数值
* 可以利用模板测试实现物体描边效果（仅说思路，具体函数使用略……）
  * 状态：片段总是通过模板测试，并设置为1
  * 绘制正方体，（正方体的片段都被设置为1）
  * 状态：模板值不等于1时才绘制
  * 绘制放大的正方体，颜色为边框（只会绘制超出原正方体的部分）

## Alpha测试

* 是否执行clip/discard裁剪/销毁 等舍弃片元的操作，在fs内部执行

## 颜色混合

* 0完全透明，1完全不透明
* 混合方程：混合结果颜色：（新的对象）源颜色 * 源因子（alpha [ 'ælfə ]） + （颜色缓冲中）目标颜色 * 目标因子（1 - alpha）

## 有透明物体时渲染顺序

* 假设有2个透明物体ab在前，不透明物体c在后，预期目标3种颜色混合
* 先绘制所有不透明的物体（假设先绘制ab，计算颜色后绘制c，深度测试的原因，c会直接丢弃）
* 按照从后往前的顺序绘制透明的物体，否则深度测试会干扰造成不正确的结果（如果先绘制a再绘制b，深度测试的原因，b会被直接丢弃）

## 纹素(Texel)

* 特指纹理的像素/片段

## 为什么是 Alpha测试，模板测试，深度测试，颜色混合 的顺序

* 按照这样的顺序是最合理的顺序，虽然early-z可以极大减少不必要的计算，但经常会遇到失效问题
* Alpha在模板前：只要不透明片段来更新模板缓冲，先aplha可以减少更新模板缓冲
* Alpha和模板在深度前：和early-z失效问题相似
* 所有测试完成再进行颜色混合（非自身，目前仅指与颜色缓冲的混合），可以保证不必要的混合计算

## 所有测试完成再进行颜色混合，会导致只剩下保留一张最近物体的片段颜色，而没有可以混合的颜色

* 理解有点问题，对每个物体依次drawcall，上个物体渲染时更新了颜色缓冲，有可以混合的颜色
