---
title: c++(6·一些关键字、数据类型、作用域……)
date: 2025-03-30 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---
# std::chrono

一个用于处理时间和日期的库

```c++
#include <chrono>

auto start = std::chrono::steady_clock::now();
//……
auto end = std::chrono::steady_clock::now();
std::chrono::duration<double> diff = end - start;

```

steady_clock：单调时钟，时间无法后退

* steady_clock::now()返回现在的时间
* steady_clock::time_point()返回更精确的时间点

high_resolution_clock：提供最高精度的时钟

# this

this指针:

* 指向调用该成员函数的对象实例
* 它只能在非静态成员函数内使用，自动隐式的通过this访问类成员
* 指针为className* const ptr，常量指针，永远指向此对象
* 它是编译器自动创建的，不会占用实际内存

作用：

* 解决名称冲突：比如函数的形参和成员变量的名称一致，用this->member name，表示此为类成员
* 返回当前对象，return *this

# 基础规则

对于可执行语句（赋值/调用/流程控制语句/异常处理……）必须在函数体/代码块内部，非可执行语句（定义/声明/预处理/别名）

# inline

内联函数：避免频繁调用的简单函数消耗栈内存的问题

特点：

* 如果包含复杂的控制语句例如 while、switch，或复杂结构递归，编译器可能会忽略 inline 建议
* 成员函数如果定义在类中，默认是内联的
* 如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外定义的开头加上 inline
* 优点：
  * 在编译阶段，将函数在调用位置进行替换展开，这样节省了函数调用的开销（保存寄存器、传递参数、跳转到函数地址、返回结果），从而提高执行效率
* 缺点：
  * 消耗内存空间：导致可执行文件增大，由于CPU缓存的空间是有限的，超出后不得不从内存中读取代码，从而降低程序的运行效率
  * 编译时间增加：由于在构建阶段处理内联函数，因此会增加构建的时间
* 使用场景：所以说应该保证inline不出现复杂的控制语句/结构，以免消耗大量内存反而降低了运行效率


# 作用域、生命周期、链接性、定义、声明、初始化、赋值：

#### 变量：

**作用域**（5类）：可被访问的范围（空间）

* 全局：全局空间定义的（在命名空间、类、函数外）在整个程序可见（可读写），不过其他文件要包含#include/extern才能访问
* 文件：全局空间定义的（在命名空间、类、函数外），用static限制，从而其他文件不可以通过#include/extern访问它
* 命名空间：命名空间定义的（在类、函数外）对整个命名空间内直接访问，外部可以通过作用域解析运算符Namespace::name 访问
* 类：在类(class/struct)内定义的变量/函数，类内可以直接访问，类外通过 类对象/指针/引用/作用域解析运算符 :: 访问（具体是否可以被类外访问取决于成员访问修饰符），普通类成员取决于类对象的作用域，静态类成员取决于类定义的位置（局部类定义不能定义静态成员）
* 局部：在函数/代码块({})中定义，仅在内部访问,且会隐藏外部的同名变量

**生命周期**（3类）：在内存中存在的时间，即创建到销毁（时间）

* 自动（栈）：局部空间定义的，从定义时创建，到离开作用域时销毁
* 静态（静态存储区）：全局空间定义的，被static修饰的，程序启动时创建，程序结束时销毁
* 动态（堆）：从 new 分配内存时创建，调用 delete 时销毁

**链接性**（3类）：能否跨文件访问

* 外部链接：可被其他文件访问
* 内部链接：仅当前文件可见
* 无链接：仅当前作用域可见

```c++
dataType variableName;//变量
returnType functionName(parameterList){functionBody}//函数
class/struct className{memberData};//类
```

**定义**：分配内存空间，并为其分配初始值，定义位置与关键字共同决定作用域、生命周期、链接性

```c++
extern dataType variableName;//变量(仅用于全局变量)
returnType functionName(parameterList);//函数
class/struct className;//类
```

**声明**：不分配内存空间，声明不会扩展作用域，只会让它在自己的作用域下正常访问（编译器可见），声明可以多次，定义只能一次

**初始化**：首次为内存块设置值，只能在定义时初始化

**赋值**：修改已有值叫做赋值

#### 函数：

**作用域**：由其定义位置决定，函数没有局部作用域，不可以定义在其他函数/代码块({})中

**生命周期**: 无论定义在哪里都是静态的

#### 类：

前置声明：
* 和普通声明的作用有差异，不能创建类对象，调用/访问成员，仅能声明指针/引用类型，作为参数/返回值类型
* 作用：减少编译依赖（include），提高编译速度，降低耦合度
* 使用场景：不需要访问成员时尽量用前置声明，打破文件相互依赖

# 重复定义

**编程规范:**

头文件：提供声明，变量声明，函数声明，类定义，模板定义……

注：

* 类定义比较特殊，只要完全相同，就不会不导致重复定义和链接错误，对于前向声明不能实例化，因此想要在其他文件实例化类，必须提供完整定义
* 模板定义比较特殊，它不会直接编译成机器码，只有实例化版本才会生成具体函数定义（在编译期间），因此不会重复定义，并且想要在其他文件实例化模板，需要提供完整的模板定义

源文件：提供具体实现

作用：提高复用性，可以这样理解，假如要复用几个函数，可以把它们定义放在一个文件，声明放在另一个文件，其他文件#include这个包含声明的文件，就可以使用它们（如果是单个函数建议用extern），且不会造成重复定义错误

# 重复包含

```c++
#ifndef _A_H_
#define _A_H_
//……
#endif

#pragma once//在vs中等同于上面
```

遵守编程规范，我们将不会造成重复定义错误，但是一个文件很有可能被重复包含，它将造成代码量过大，为了解决这个问题，可以用上述两种方法

如果没有定义宏，就定义宏，并包含代码段，如果包含过，就已经定义了宏，条件失败，不会再次包含代码段

# static

static静态：用来修改变量/函数的作用域、生命周期、链接性，主要作用修改生命周期为静态

```c++
#include <iostream>
using namespace std;

int n = 1; //全局变量

void func()
{
	static int a = 2; // 静态局部变量
	int b = 5; // 局部变量
	a += 2;
	n += 12;
	b += 5;
	cout << "a:" << a
		<< " b:" << b
		<< " n:" << n << endl;
}

void main()
{
	static int a; // 静态局部变量
	int b = -10; // 局部变量
	cout << "a:" << a
		<< " b:" << b
		<< " n:" << n << endl;
	b += 4;
	func();
	cout << "a:" << a
		<< " b:" << b
		<< " n:" << n << endl;
	n += 10;
	func();

	system("pause");
}
```

示例：

* a初始为0，
  * func中内部作用域a隐藏了外部作用域a，输出4，
  * 回到外部局部作用域结束，返回0，
  * func，由于生命周期为静态，局部作用域再次可见，定义并非再次创建，而是返回静态内存中的a，返回6
* b初始为-10，
  * 进入内部隐藏外部，返回10，
  * 返回外部，由于+4返回-6
  * func，由于生命周期自动，上一次的销毁重新创建，返回10
* n初始为1，
  * func没有定义同名的变量，不会隐藏，直接修改，返回13
  * 返回外部，由于被修改返回13，
  * +10，进入func，再次+12，返回35

全局静态变量：全局作用域用 static 修饰的变量，作用域限制为文件，生命周期静态，链接性为内部

局部静态变量：局部作用域用 static 修饰的变量，作用域局部，生命周期静态, 再次调用函数执行定义指令时不会再次分配内存，而会从静态区直接查找已创建的对象

```c++
class Example {
public:
    static int count;  
    static const double PI; 
    static void printCount();
};
//类外定义
int Example::count = 0;   
const double Example::PI = 3.14; 
void Example::printCount() {
    std::cout << "Count: " << count << std::endl;
}
```

静态成员变量：类中用 static 修饰的变量，类作用域，生命周期静态，保证了类内的唯一性

静态成员函数：类中用 static 修饰的函数，类作用域，生命周期静态，保证了类内的唯一性

静态成员特点：

* 作用域：类作用域（可以理解为从类对象提升为类定义）
* 访问方式改变:可以通过作用域解析运算符 :: 直接调用，而不是创建类对象
* 必须在类外定义，定义时不添加static关键字
* 没有隐藏的this指针，不能直接访问任何非静态成员（可以通过类对象间接访问）
* 遵守访问修饰符的原则

# 类定义位置

* 全局
* 局部
  * 限制：
    * 不能定义静态成员
    * 只能访问外层作用域的 静态生命周期 和 枚举常量，不能访问普通局部变量
    * 局部类不能用于模板参数

# extern

声明变量/函数为外部链接性

```c++

//1.cpp
int global_var = 42; 
void print_hello() {
  std::cout << "Hello!";
}
int a = 10;//定义a
//extern int a = 20;//定义a，重复定义错误

//2.cpp
extern int global_var; 
extern void print_hello(); 
//extern int a = 20;//定义a，重复定义链接错误

```

注意：

* extern仅可以修饰全局变量/函数，不能修饰局部变量
* extern可以放在任意的位置，但作用域是不同的
* static 限制作用域，extern 扩展作用域
* 如果在extern的时候给变量赋值 == 定义

问题：为什么要用extern 函数呢？直接#include相应的头文件不可以吗？

* 不会引入大量头文件，进而不会引入大量的无关函数,会加速程序的编译

# const

* 常量对象：
  * const关键字定义常量：表示内存存储的值不能被修改，是只读的，否则将发生编译错误，防止程序员意外修改
  * 定义常量时必须初始化，并且常量不能被赋值
  * const对变量的作用域、生命周期、链接性的影响：

    ```c++
    // file1.cpp
    const int x = 10;  //定义时必须初始化
    extern const int y = 10; 

    // file2.cpp
    extern const int x;  // ❌ 错误
    extern const int y;  // ✅ 正确
    ```

    * 对于全局作用域常量，限制为文件作用域、内部链接性，也就是其他文件无法通过extern访问
    * 如果想要保持外部链接性，必须在定义时加extern，这样表示常量为全局作用域、外部链接性

    ```c++
    //测试
    const int a = 7;
    int main(){
      int *p = (int *)(&a);//使用C风格强制转换去除常量性
      *p = 8;//通过指针间接修改内存值// ❌ 运行时触发断言
      
      const volatile int b = 7;
      p = (int *)(&b);
      *p = 8;// ✅ 运行没有问题，且b常量被修改
    }
    ```

  * 对于此测试，表明在特定情况下常量也是会被修改的
* 修饰指针
  * 顶层const：对象本身是常量，不能被修改，常量指针，不可以修改指向的对象
  * 底层const：所指向的对象是常量，对常量的指针，不可以修改指向对象的值
* 修饰引用
  * 引用不是对象，不可以被const修饰，所以仅有对常量的引用，不可以修改绑定对象的值
* 常量类对象：
  * 表示该对象内的任何类成员数据都不能被修改
  * const类对象只能调用const成员函数，而非const类对象可以调用任意的成员函数，如果const类对象允许调用非const成员函数，则类成员数据可以被修改，违背了常量类对象性质
* 常量类成员数据：
  * 必须在构造函数的成员初始化列表中设置初始值，但对于静态常量数据成员，需要在类外设置初始值
  * 不可以被赋值
* 常量类成员函数：

  ```c++
  returnType func() const;
  ```

  * 不可以修改类成员数据，无论它是否具有const性质
  * 常量成员函数 和 非常量成员函数 都可以访问类的const成员和非const成员
  * 常量成员函数的定义和声明都要含有const关键字
  * const member function和non-const member function，是属于函数重载
  * 如果const成员函数想修改成员变量值，可以用mutable修饰目标成员变量

# constexpr常量表达式

* 表达式
  * 运算符分类：
    * 算术运算符(+、-、*、/、%)；返回数值
    * 逻辑运算符(!、&&、||)；返回bool
    * 关系运算符(<、<=、>、>=、==、!=)；返回bool
    * 赋值运算符(=、+=、-=、*=、/=、%=、<<=、>>=、&=、|=、^=)；返回左操作数的引用
    * 递增、递减运算符(++、--)；前置先自增减再返回，后置先返回再自增减，前置返回操作数引用，后置返回操作数原值副本
    * 位运算符(~、<<、>>、&、|、^)；二进制位运算，返回数值
    * 条件运算符(? \:)；返回冒号左侧或右侧表达式的值
    * 成员访问运算符(. 、->)；
    * 指针运算符：（*）（&）
    * 求字节数运算符：（sizeof）；
    * 逗号运算符：（,）；用于把若干表达式组合成一个表达式，返回最右侧表达式的值
    * 特殊运算符：（( )、[ ]、-> ）
    * ……
  * 求值顺序
    * 赋值：从右侧开始计算，比如a = b = c,先计算 b = c,再计算 a = (b = c)
    * &&：先求左侧表达式如果为真继续求右侧表达式，返回bool值
    * ||：先求左侧表达式如果为假继续求右侧表达式，返回bool值
    * 条件： 求？左侧表达式，条件为真求：左侧表达式，条件为假求：右侧表达式
  * n元运算符：需要n个操作数的运算符
  * 表达式：运算符和操作数的组合，操作数：>= 1 个, 运算符：>= 0 个
  * 字面值：只有一个操作数的表达式，其中操作数不是变量，是数值，形如'a'， "ab"， 4， false， 1.0……

* 常量表达式:

  ```c++
  //非常量表达式
  const int c = 3;
  const int d = c + 2;

  //非常量表达式
  int staff_size = 27;
  const int sz = get_size();
  ```

  * 一种特殊的表达式，在编译期间就可以计算出结果的表达式，它的值是常量
  * 形式：字面值常量，字面值常量和操作符的组合，被const修饰的变量其初始化值是常量表达式，常量表达式和常量表达式的组合

* constexpr变量
  * 将变量声明为constexpr，由编译器验证等式右侧是否是常量表达式，如果是则将它们放在编译期间计算，如果不是编译错误
  * 作用：加快运行速度
  * constexpr 变量一定是const的，但const变量不一定是constexpr
* constexpr函数
  * 函数返回类型及所有形参的类型都是字面值类型，而且函数体中必须有且只有一条return 语句
  * 作用：可以用来初始化constexpr变量

# 数据类型

数据类型决定内存分配的存储空间的大小

```c++

数据类型分类（C++）
├── 内置类型（Built-in Types）: C++语言本身直接支持的数据类型
│   ├── 基本数据类型（Fundamental Types）: 不可再分解的最小数据类型
│   │   ├── 算术类型（Arithmetic Types）: 支持算术运算的基本数据类型
│   │   │   ├── 整型（Integral Types）
│   │   │   │   ├── 字符类型
│   │   │   │   │   ├── char 1字节
│   │   │   │   │   ├── wchar_t 宽字符2字节
│   │   │   │   │   ├── char8_t 1 字节，明确表示 UTF-8 编码的 Unicode 字符
│   │   │   │   │   ├── char16_t 2 字节，表示 UTF-16 编码的 Unicode 字符
│   │   │   │   │   └── char32_t 4 字节，表示 UTF-32 编码的 Unicode 字符
│   │   │   │   ├── 布尔类型：bool
│   │   │   │   └── 整数类型
│   │   │   │       ├── short 2 字节
│   │   │   │       ├── int 4 字节
│   │   │   │       ├── long 4/8 字节 L 或 l 后缀
│   │   │   │       └── long long 8 字节 LL 或 ll后缀
│   │   │   └── 浮点类型（Floating-point Types）
│   │   │       ├── float 4字节
│   │   │       ├── double 8字节
│   │   │       └── long double 8字节
│   │   └── void 类型：表示无类型或空类型
│   └── 复合类型（Compound Types）: 可再分解的最小数据类型
│       ├── 指针（Pointer）: T*
│       ├── 数组（Array）: T[N]
│       ├── 引用（Reference）
│       │   ├── 左值引用：T&
│       │   └── 右值引用：T&& 
│       ├── 函数类型（Function Types）
│       └── 限定类型（Qualified Types）
│           ├── const限定：const T
│           └── volatile限定：volatile T
│
├── 标准库类型（Standard Library Types STL）: C++标准库提供的数据类型
│   ├── 容器类（Containers）
│   │   ├── 序列容器
│   │   │   ├── vector
│   │   │   ├── array (C++11)
│   │   │   ├── deque
│   │   │   ├── forward_list (C++11)
│   │   │   └── list
│   │   ├── 关联容器
│   │   │   ├── set
│   │   │   ├── map
│   │   │   ├── multiset
│   │   │   └── multimap
│   │   └── 无序关联容器 (C++11)
│   │       ├── unordered_set
│   │       ├── unordered_map
│   │       ├── unordered_multiset
│   │       └── unordered_multimap
│   ├── 字符串类：string, wstring
│   ├── 智能指针 (C++11)
│   │   ├── unique_ptr
│   │   ├── shared_ptr
│   │   └── weak_ptr
│   ├── 工具类
│   │   ├── pair
│   │   ├── tuple (C++11)
│   │   └── variant (C++17)
│   └── 其他
│       ├── optional (C++17)
│       ├── any (C++17)
│       └── function (C++11)
│
└── 自定义数据类型（User-defined Types）：C++中允许我们定义自己的数据类型
    ├── 类类型（Class Types）：自定义数据类型
    │   ├── class
    │   └── struct
    ├── 枚举类型（Enumeration Types）：自定义整数常量集合
    │   ├── 无作用域枚举：enum
    │   └── 有作用域枚举：enum class (C++11)
    └── 联合体：union：多个数据共享同一内存
```

![1743320107935](/assets/img/blog/c++/修饰符.png)

# 变量 初始化方式

**隐式初始化：**

```c++
int x; 
int* p;
int* p1 = new int;
func(){
  static a;
}
class B{
  int a;
  int* p = new int;
};
```

默认初始化：

* 定义变量时未显示初始化就会执行默认初始化
* 静态生命周期
  * 初始化为0、
  * 指针为nullptr，
  * 类对象调用默认构造函数，详见\<特殊成员函数_构造>
* 自动/动态生命周期
  * 值未定义（如果访问和使用未定义的对象，程序将发生错误）
  * 指针未定义，
  * 堆内存未定义
  * 类对象调用默认构造函数，详见\<特殊成员函数_构造>

```c++
func(){
  int* p1 = new int;
}
```

* _注意: 指针和堆内存应该分开来看：指针内存在栈内存->自动生命周期 / 静态内存->静态生命周期，堆内存在动态内存->动态生命周期_
  * 使用方式：如果未使用new不会分配堆内存
  * 如上所示，func结束后p指针作为局部对象内存释放掉，而通过new分配的堆内存未被释放

```c++
int x(); 
int* p1 = new int();
func(){
  static a();
}
class B{//合成默认构造函数
  int a();
  int* p = new int();
};
```

零初始化

* 使用空小括号或空花括号进行的初始化
* 初始化为0
* 指针分配内存
* 堆内存初始为0
* 对于类对象，如果没有自定义默认构造函数，调用合成默认构造函数，详见\<特殊成员函数_构造>（其中默认初始化部分修改为 零/值初始化）……

```c++
struct A {
    int x, y;
    A(): x(), y(1) {}//自定义的默认构造函数
};
```

值初始化：

* 使用空小括号或空花括号进行的初始化
* 非类类型和零初始化一致
* 对于类对象，如果有自定义默认构造函数，属于值初始化，调用自定义的默认构造函数，详见\<特殊成员函数_构造>（其中默认初始化部分修改为 零/值初始化）……

**显式初始化：**

```c++
int i = 1;
std::string s2(5, 'a');
```

直接初始化：
  
* 使用=号/有参小括号初始化，类型不一致
* 内置类型直接使用参数初始化
* 类对象调用匹配的非默认自定义构造函数

```c++
int i = 1;  // 直接初始化
int j = i;  // 拷贝初始化
std::string s1 = "hello"; 
```

拷贝初始化：

* 使用=号/有参小括号初始化，类型一致
* 内置类型直接使用参数初始化
* 类对象调用拷贝构造函数

```c++
struct Point {
    int x, y;
};
```

聚合初始化：

* 使用={有参}初始化 数组、结构体、联合体等，
* 需要满足聚合类型条件（即最基本的数据集合体）：非静态数据成员必须都是公有的，没有自定义构造函数，没有基类，没有虚函数

```c++
struct A {
    int x, y;
    A(int x, int y): x{x}, y{y} {}
};
A a{1, 2};  // 直接初始化，调用构造函数
A b{a};     // 拷贝初始化
std::vector<int> v{1, 2, 3};//vector类重载了std::initializer_list\<T>构造函数
```

列表/万能初始化：

* 使用有参花括号进行的初始化，
* 它有严格的类型检查（比如不允许精度丢失），检查失败不会通过编译
* 它非常通用，可以调用构造/拷贝构造函数，当列表为空调用默认构造
  * 如何区分调用了构造/拷贝构造函数 还是直接初始成员
    * 如果为聚合类型，直接初始成员
    * 否则，调用构造/拷贝构造函数
* 初始化列表的类型为std::initializer_list\<T> ，如果有相关重载的构造函数，优先调用