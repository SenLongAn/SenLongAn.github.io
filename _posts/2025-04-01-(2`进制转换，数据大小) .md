---
title: 2`进制转换，数据大小
date: 2025-04-01 12:00:00 +0800
categories: [计算机基础]
tags: []     # TAG names should always be lowercase
math: true
---

# 进制基础

**底层表示**

计算机底层是用二进制（0/1）表示的，每个二进制数字用一个位存储，它是最小到的传输单位bit位/比特，最小的存储单位是byte字节 == 8位（因为一个位通常不能表示一个完整的信息）

一个ACSII码（有128个字符，包括数字，字母，通用/控制符号）占一个字节，它是在构建的汇编阶段的编码方式之一，即将这些字符转换为计算机可以理解的二进制码，比如这样的操作'a' - 'a' 的结果为0

**原码，反码，补码**

我们现在可以用不同的二进制组合表示不同的字符，那么如何表示 正负，加减运算……呢?

```c++
正数1的原码为： 0 0000001
负数-1的原码为：1 0000001
```

* 原码
  * 二进制的首位当作标记符，[ 0 ]表示正数，[ 1 ]表示负数

```c++
加法运算 ：0+1=1，1+0=1，0+0=0，1+1 = 0（进位1）

    1010
+   0010
=   1100

3 + (-5) = -2
    0 0000011 原
+   1 0000101 原
=   1 0001000 原 == -8
```

*  * 计算机只会加法不会减法，所以应该将减法换算为加法（例如3 - 5 = 3 + (-5)），但直接用原码计算的结果是错误的

```c++
-5的原码为：1 0000101
-5的反码为：1 1111010
```

* 反码
  * 为了保证结果正确，数学家规定在运算时负数使用反码表示
  * 正数的反码为本身,负数的反码为，除符号位不变其余位取反, 运算结果再次转为原码
  * 从反码到原码，除符号位不变其余位取反
```c++
1 + (-1) = 0
   0 0000001 反
+  1 1111110 反
=  1 1111111 反
   1 0000000 原 == -0
```
*  * 但是它有时仍会出现问题，比如上面的用例，0没有负数
* 补码
  * 补码正是用来解决+0和-0的问题，数学家规定在运算时负数用补码表示
  * 正数的补码为本身，负数的补码为反码再加上1
  * 原码到补码：原->反->补

```c++
1 1111110 -> 1 0000001 -> 1 0000010
```
*  * 补码到原码：除符号位不变其余位取反,再加1










从 -2^(bit-1)  ——  2^(bit-1)-1
