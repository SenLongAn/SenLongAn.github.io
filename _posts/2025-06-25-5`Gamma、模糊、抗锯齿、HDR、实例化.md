---
title: Gamma、模糊、抗锯齿、HDR、实例化
date: 2025-06-25 12:00:00 +0800
categories: [OpenGL]
tags: []
math: true
---

## Gamma伽马校正(jiao zheng)

* 物理亮度即光子数量，数量翻倍时是真实的物理亮度，线性亮度
* 人眼感知，对暗部变化更敏感（暗部只需要较少的光子数增幅，就会感到明显的变化），CRT显示器正好符合人眼感知，非线性亮度即^2.2
* 图中，横轴光子数量，纵轴颜色/亮度值，它们都以归一化表示,中间是线性，下方^2.2，上方^1/2.2 ~= 0.45
* 观察发现，^2.2比^1的整体要暗，但0和1颜色是相等的
* Gamma校正：应用Gamma倒数（1/2.2），线性颜色^1 -> 显示器^2.2 -> Gamma^1/2.2 颜色变回最初设置的线性颜色
* sRGB颜色空间：gamma2.2
* 在opengl中使用Gamma校正：

  * 内建的sRGB帧缓冲：glEnable(GL_FRAMEBUFFER_SRGB);（注意：我们应在最后的颜色计算应用校正，否则将使用不正确的颜色值）
  * 手动在每个fragment shader中校正，更加简单的方式新增一个后期处理shader，仅在quad上校正一次
* sRGB纹理：在sRGB中制作的纹理
* 不使用校正时没有问题：纹理在sRGB空间创作和显示，这是统一的
* 但应用了gamma后，纹理颜色就会很亮，因为我们在sRGB空间制作纹理，会通常将它的颜色设置的更亮，以便达到预期颜色（比如0.5的颜色值），经过gamma后它的颜色变为了线性颜色，会超出预期颜色
* 为了解决这个问题，有几种方案：

  * 在线性空间工作：线性颜色^1 -> 显示器^2.2 -> Gamma^1/2.2 颜色变回最初设置的线性颜色
  * 每次使用前^2.2，opengl中提供了内置的纹理格式GL_SRGB和GL_SRGB_ALPHA，它们会自动校正为线性空间

## 均值模糊，高斯模糊

* 使用滤波函数，生成卷积核对应的权重
* 卷积核的范围越大，图像就越模糊
* 均值滤波函数：1/width*height，width以及height分别为卷积核的宽与高，因此每个权重值都相等
* 高斯滤波函数：高斯模糊基于高斯曲线（一个钟形曲线，符合正太分布），中间的值达到最大化，随着距离的增加，值不断减少
* 两步高斯模糊（优化）
  * 想象对于32×32的卷积核，要对每个像素做1024次采样计算，计算量非常庞大
  * 由于高斯模糊符合正太分布，它可以拆分成一维卷积操作？？？数学原理，总共只需要32+32次计算
  * 为什么要两个帧缓冲，如果只有一个帧缓冲一个纹理，每次绑定自身的输出颜色纹理附件，使用自身帧缓冲不行吗
    * 纹理不能只有一个不能同时读写，必须要两个纹理，纹理一个读一个写，pingpong切换，
    * 帧缓冲我认为不需要两个，
  * 权重值在代码怎么计算的
    * 没有计算，直接使用的特定数值
  * 文章中为什么amount = 10
    * 每2次是一次水平+一次垂直，10次相当于做了5次的高斯模糊，模糊次数越多越模糊

## 抗锯齿

* 走样：渲染图像的边缘有锯齿
* 形成原因：像素分辨率和栅格化的底层实现，每个像素的中心包含有一个采样点，当图元栅格化时，会对每个像素检查采样点是否在图元内，如果在就形成片段，不在就不会形成片段
* 假设分解为4个子像素/4个采样点（注意不是5个，中心sample不需要了）
* SSAA
  * 原理：
    * 使用更高的分辨率渲染场景，
    * 在depth_buffer和color_buffer数组大小扩充到4n，
    * 会对每个像素执行覆盖判断，对覆盖片段执行fs（标准深度测试）和深度测试，
    * 降采样，将几个子像素的颜色值平均给父像素
  * 带来很大的内存和性能开销，效果最好
* MSAA
  * 原理：
    * 增加像素的采样点数量，
    * 在depth_buffer和color_buffer数组大小扩充到4n，
    * 会对每个采样点执行覆盖判断，
    * 对覆盖片段（至少有一个sample通过测试）执行一次fs，
    * 对每个采样点执行深度测试，并把颜色拷贝到通过深度测试的sample，
    * 将采样点颜色值平均给像素
  * 带来很大的内存开销，性能开销要比SSAA显著降低（颜色拷贝这一步，SSAA对于每个图元都需要对覆盖的子像素光照计算，而MSAA只是将颜色拷贝给子采样点），效果略次于SSAA

## HDR(High Dynamic Range)高动态范围

* 显示器的颜色值在0——1 LDR(Low Dynamic Range,低动态范围)之间，如果那些超过1的颜色被直接约束到1，将损失很多的细节，因此我们应允许暂时保留颜色值，然后通过一定方式合理转换到范围之间，从而防止损失细节，这个过程叫做色调映射(Tone Mapping)
* Reinhard色调映射算法：Color / (Color + vec3(1.0));
* Exposure曝光参数：vec3(1.0) - exp(-Color * exposure);低曝光值会显著减少黑暗区域的细节，高曝光值会显著减少亮部区域的细节，

## 实例化

* drawcall极为消耗性能，因此应避免它的调用，实例化技术一次drawcall可以绘制大量的物体，当（shader，数据，状态）只有很少的变化时，可以使用它
* opengl实现方式
  * 场景，渲染大量四边形，仅有位置偏移
  * uniform offset数据数组传入shader，通过内置instanceID获取对应数据
  * 但是实例非常多，会超过uniform的上限，应用实例化数组，offset作为顶点数据传入
