---
title: OpenGL复习(测试与混合、阴影)
date: 2025-06-23 12:00:00 +0800
categories: [OpenGL]
tags: []
math: true
---

# 测试与混合

### 深度测试

* 对片元排序，实现遮挡关系效果

### z值，深度测试，深度缓冲，深度值

* 每个顶点在几何阶段计算z值，片段使用插值z，在深度测试阶段，如果片段通过测试（常用方式z<深度值），更新深度缓冲的深度值

### 深度值为什么是非线性的

* 经过平截头体挤压和/w的共同作用下，深度值非线性，近处精度高，远处精度低（nf直接的点映射到0——1范围，通常在1/50前的距离占了0.5一半的精度，而在后面49/50的部分占了0.5一半的精度）

### 深度可视化

* 非线性深度：距离我们极近的物体有剧烈的颜色变化，而其余比这远的物体几乎呈现全白
* 线性深度：随着距离的增加有自然过渡的颜色变化

### 深度测试使用的是渲染流水线中那个阶段的值

* NDC空间的z值，再经过从 -1——1的值变为0——1后，它是非线性的

### 深度值的精度是指

* nf之间投射到0——1的范围，线性的是均匀投射的，非线性可能很少的距离变化就投影到了一半的0.5的深度值（0.5就是精度）
* 近处精度高，在极为解决n的位置，占了接近一半的精度
* 它和1/z成正比，和z呈反比，也就是z深度越远，精度越小，占深度值的范围越少
* 发现/z其实就是/w

### 如何获取线性深度

* 经过投影矩阵会变为非线性深度，所以我们恢复到投影前，视图坐标下的z值，这个z-n相对于f-n才是线性深度

### 模板测试

* 模板值通常8位，因此每个片段可以表示256个值，根据模板值，选择丢弃/保留片段
* 位掩码(Bitmask)：按位运算，改变数值
* 可以利用模板测试实现物体描边效果（仅说思路，具体函数使用略……）
  * 状态：片段总是通过模板测试，并设置为1
  * 绘制正方体，（正方体的片段都被设置为1）
  * 状态：模板值不等于1时才绘制
  * 绘制放大的正方体，颜色为边框（只会绘制超出原正方体的部分）

### Alpha测试

* 是否执行clip/discard裁剪/销毁 等舍弃片元的操作，在fs内部执行

### 颜色混合

* 0完全透明，1完全不透明
* 混合方程：混合结果颜色：（新的对象）源颜色 * 源因子（alpha [ 'ælfə ]） + （颜色缓冲中）目标颜色 * 目标因子（1 - alpha）

### 有透明物体时渲染顺序

* 假设有2个透明物体ab在前，不透明物体c在后，预期目标3种颜色混合
* 先绘制所有不透明的物体（假设先绘制ab，计算颜色后绘制c，深度测试的原因，c会直接丢弃）
* 按照从后往前的顺序绘制透明的物体，否则深度测试会干扰造成不正确的结果（如果先绘制a再绘制b，深度测试的原因，b会被直接丢弃）

### 纹素(Texel)

* 特指纹理的像素/片段

### 为什么是 Alpha测试，模板测试，深度测试，颜色混合 的顺序

* 按照这样的顺序是最合理的顺序，虽然early-z可以极大减少不必要的计算，但经常会遇到失效问题
* Alpha在模板前：只要不透明片段来更新模板缓冲，先aplha可以减少更新模板缓冲
* Alpha和模板在深度前：和early-z失效问题相似
* 所有测试完成再进行颜色混合（非自身，目前仅指与颜色缓冲的混合），可以保证不必要的混合计算

### 所有测试完成再进行颜色混合，会导致只剩下保留一张最近物体的片段颜色，而没有可以混合的颜色

* 理解有点问题，对每个物体依次drawcall，上个物体渲染时更新了颜色缓冲，有可以混合的颜色

# 阴影

* 阴影：
  * 形成：光的直线传播沿途经过的物体，后面所有物体被首个物体遮挡，不能被光直接照射，形成阴影
  * 作用：更好体现物体位置关系
  * 平行光阴影_实现方式：
    * pass1：从光的视角渲染一张深度纹理，和摄像机渲染不同的是使用光的V矩阵（平行光源的位置和方向），使用帧缓冲离屏渲染获得深度纹理
    * pass2：从摄像机视角渲染场景，根据之前渲染的深度纹理，由于fs中实际不需要我们自己对每个片段做计算（opengl内部实现插值做计算），和vs一样仍只需要考虑每个顶点，我们可以根据顶点数据MVP变换、/w，获得顶点在DNC光空间位置，使用的深度值是DNC空间的，比较点在光DNC空间的z，和经过视口变换得到的uv坐标获取深度值，如果>这个深度值，表面点处于阴影中，否则不在阴影中（本质就是转换到同一空间下比较）
  * 阴影失真
    * 摩尔纹（通常是带有条纹的纹理，形成干扰图案，比如弧形、螺旋线……）
      * ![1](../assets/img/blog/OpenGL/阴影摩尔纹成因.png)
      * 成因：一个深度贴图像素的范围，会覆盖场景的一片区域，而这片区域统一使用像素中心采样点的位置计算深度值（重心插值），而颜色缓冲像素采样点变换到3D场景位置，不一定位于深度贴图像素采样点投射的位置，相邻的颜色缓冲像素有的判断为阴影，有的判断为非阴影，出现黑白交替
      * ![1](../assets/img/blog/OpenGL/非阴影差异大.png)
      * 特点：通常出现在非阴影区域，因为深度值差异较小，而阴影区域深度值差异较大
      * ![1](../assets/img/blog/OpenGL/bias偏移.png)
      * 解决方式：阴影偏移，对当前DNC.z深度-偏移值，让表面看起来比实际位置更高一点，这样很大一部分错误的认为深度更高的位置会得到正确的结果
      * ![1](../assets/img/blog/OpenGL/覆盖区域.png)
      * float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);
      * 动态偏移：越垂直于光源的表面，应用偏移越小，角度差异越大的表面，应用偏移越大，这是因为越垂直，像素覆盖的区域就越小，如果偏移过大会产生不正确的结果
    * 悬浮
      * 成因：物体被遮挡形成阴影，如果这个遮挡物体的深度和被遮挡物体的深度差异不大，那么应用较大偏移后，在深度差异不大的位置，原本应该形成阴影，但错误的判断为非阴影
    * 阴影边界
      * 成因：超出光平截头体的范围，默认被判断为阴影，就会在场景形成明显边界
      * 解决方式：修改深度贴图的环绕方式，并判断如果深度值超过1，返回阴影值0
  * PCF阴影抗锯齿
    * ![1](../assets/img/blog/OpenGL/阴影锯齿.png)
    * 成因：当阴影贴图分辨率较低，多个颜色缓冲像素和同一个深度值比较，有一部分区域像素位于阴影，有另一部分像素位于非阴影，就会形成明显的区块划分即锯齿边界
    * 解决方式：PCF，为了产生柔和的过渡，一个颜色缓冲像素的采样，不仅仅依赖于一个深度贴图像素，还依赖周围8个像素（3*3-1），把结果取平均值
  * 线性深度
    * 透视投影的深度值是非线性，应该转变为线性深度值，使得远近精度统一
  * 点光源阴影——实现方式：
    * pass1：从光的视角1次渲染1张立方体深度贴图，而不需要6次渲染6张深度贴图，我们需要1个帧缓冲，6个方向的V矩阵，通过几何着色器内建变量gl_Layer，指定把图形渲染到立方体贴图的哪一个面，遍历6次，生成图元的18个顶点，通过V矩阵变换到各个面中
    * pass2：从摄像机视角渲染场景，现在使用片段和光的方向向量采样深度值
  * PCF：
    * 由于现在变为点光源，PCF的过滤应该变为3个维度（4\*4\*4 = 64次）

    ```c++
    vec3 sampleOffsetDirections[20] = vec3[]
    (
      vec3( 1,  1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1,  1,  1), 
      vec3( 1,  1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1,  1, -1),
      vec3( 1,  1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1,  1,  0),
      vec3( 1,  0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1,  0, -1),
      vec3( 0,  1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0,  1, -1)
    );
    ```

    * 优化：三维泊松圆盘采样，是经过精心挑选或生成的，以确保它们在球体表面上分布得相对均匀, 并且用较少的采样提高性能