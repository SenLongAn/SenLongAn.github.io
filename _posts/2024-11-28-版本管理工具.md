---
title: 版本管理工具
date: 2024-11-28 12:00:00 +0800
categories: [版本管理]
tags: []     # TAG names should always be lowercase
math: true
---
# 版本管理工具

当我们多人协同开发，要面临同一个项目的维护，我们希望有 追溯历史版本（包括谁做了什么修改），分工协作（增删改，避免代码冲突和重复），版本管理（发布版本、测试版本等），分支开发 等功能，因此我们使用 版本管理工具，其中最常使用的为git 和 svn：

## Git vs. SVN

Git：

* **分布式**版本控制系统,每个开发者都可以在本地完整地复制整个代码仓库，并且可以独立地进行开发和版本控制，完整的项目历史和版本信息，进行提交、分支、合并等操作
* 树状结构模型，
* 数据保存在本地主机，
* Git的版本号是全局唯一hash标识
* 有多个远程仓库
* 快照机制保证完整数据（拍照片），备份
* 速度较快
* 轻松地进行分支管理和合并
* 操作命令比较复杂
* 适用于大规模，开源，团队分别在不同的地理位置

SVN：

* **集中式**版本控制系统,需要通过中央服务器进行版本控制，每个开发者只能从中央服务器获取代码
* 扁平结构模型，
* 数据保存在中央服务器
* 递增的整数版本号
* 只有一个中央仓库
* 同步到中央服务器，保证完整数据
* 速度较慢
* 分支管理和合并较困难
* 操作命令简单
* 适用于项目较简单，团队成员集中在一个地理位置

## svn

##### Serve

如果想作为管理员需要下载VisualSVN Serve [下载链接](https://www.visualsvn.com/server/)

创建repository仓库，右键repositories点create，填写仓库名，

添加用户，设置用户名和密码，其他人用此账户密码登录就可以访问仓库了

设置用户权限，右键repositories点properties属性，点add添加用户，下方选择permissions用户权限，点确定

##### Client

作为客户需要下载TortoiseSVN [下载链接](https://tortoisesvn.net/)

如果右键鼠标出现SVN菜单，即安装成功

想要Checkout检出仓库代码，需要获取到仓库URL，通过server上右键仓库，copy url

其余操作省略 ……

# Git

**前言**

工作区->add->暂存区->commit->本地仓库->push->远程仓库

可以把每个版本构建成树型结构，每个提交记录相当于一个节点，有唯一的哈希名，每个新提交记录都作为上一次的子节点，每个分支相当于一个新的枝杈，当向指定分支提交时，会在指定分支新增子节点

**初始**

init初始化，在指定路径创建一个空的本地仓库

remote set-url <远程名称> <远程仓库URL> 更新本地仓库关联的远程仓库URL

clone <远程仓库URL> 克隆，将远程仓库完整复制到工作区，包括所有分支和历史记录

* git init + git remote add ≈ git clone

**常用命令**

fetch获取，从远程仓库下载最新数据，但不自动合并到本地分支

* pull = fetch + merge

```c++
git add .               // 添加所有修改
git add -u              // 添加已跟踪文件的修改
git add -p              // 交互式选择部分修改
git add src/            // 添加指定目录
```

--version版本

add <文件/目录> 添加，将工作区的更改推送到暂存区

commit -m "提交信息" 提交，将暂存区的修改创建为一个新提交

push <远程名称> <分支名> 推送，将本地提交推送到远程仓库

* push -f <远程名称> <分支名> 强制推送

pull <远程名称> <分支名>拉，从远程仓库拉取

cherry-pick <提交哈希，提交哈希 ……> 将某提交复制到当前的分支下

**查看**

log查看本地提交记录，以便获取哈希值，按Q退出

status查看暂存区状态

**分支：**

branch分支，在本地仓库创建一个分支，默认分支是main/master分支，分支指针会指向本分支的最新节点

* git branch -d 删除指定分支
* git branch -f 分支名 + 某个节点 ：让分支指针指向另一个提交

**撤销：**

reset恢复/撤销，把分支指针回退几个提交记录来实现撤销改动

revert 是通过创建一个新的提交来撤销指定提交的更改，更适合团队协作

**移动:**

HEAD头指针，每次提交后总是指向当前分支上最近一次提交记录

checkout/switch检出，head切换到某分支上/某哈希节点上

^向上移动1 个提交记录

~< num > 向上移动num个提交记录

**合并：**

merge合并，将指定分支合并到当前分支，并创建一个新的提交记录，它不会破坏历史，但容易造成分支结构十分复杂和紊乱，适合团队协作

```c++
git checkout feature
git rebase main//将feature变基到main
git checkout main
git merge feature//将feature合并到main
git br -d feature//删除feature分支
```

rebase变基，将当前分支变基到指定分支下，它会自动与指定分支修改整合，它会破坏历史，但分支结构线性清晰，适合一个人开发

* 通常会配合merger使用，因为变基后它只是在rebase上应用了修改，应该将整合的内容合并到目标分支（通常是main分支），从而它包含了最新的版本
* rebase -i +（从当前head结束到指定的节点开始）会展现一个交互对话框，我们可以对提交记录做个排序/删除，将修改后的

# Git Extensions

Git Extensions是git的可视化工具，首先在GitHub官网下载安装

**设置：**

在每次开始运行前都会出现一个setting设置框

Git Extensions->设置源，这里是Git Extensions正常工作所必须的基本设置，红——不正确设置，黄——不推荐设置，绿——正确的设置

git基本设置（用户名，邮箱……）既可以通过Git Extensions中git->设置 可视化去修改，也可以通过git命令行直接更改，两边都可以看到相同的设置更改

此外还包括外观，通用，高级……设置

**窗口**

上方：

* 开始：
  * 创建档案库
  * ……
* 档案库：
  * 管理远程仓库：可以手动关联远程，包括远程仓库名origin，和url
* 命令：
  * 提交，拉取，推送，创建/删除/合并分支……

左侧：

* 查看本地仓库分支，在关联了远程后可以查看远程的分支
* 子模块，标签，暂存

右上：

* 最左侧版本树，根节点在最下方，每新增一个操作，都会向上方创建一个节点，
* 每个节点的右边分别是：操作的记录，用户，时间，哈希值

右下：

* 差异：
* 文件树：节点包含的所有文件

**开始使用：（实例）**

创建仓库：

* github上创建远程仓库，包括LICENSE,README
* 在GitHub上添加Personal access tokens 个人访问令牌，就可以在Git Extensions上使用GitHub
* 在主界面克隆github版本库：==clone，选择远程的仓库，https协议，选择本地目标文件夹开始拷贝
* 克隆的文件夹内的文件夹和文件都剪切到工作区，把总文件夹删除
* 使用Git Extensions创建本地仓库==init（由于上面已经clone，init就不用执行，并已经remote了），目录选择工作区

分支：

* 创建分支：==branch新建一个自定义名称的分支
* 我们会创建2个分支，名为v1（我们）,v2（同事）
* 切换分支：==checkout，通过右键选择分支->切换分支
* 切换到v1
* 修改工作区，新增文件1（当我们切换分支时，工作区的内容也会跟随修改，即仅显示此分支的内容）

提交命令：==commit

* 会打开独立窗口
* 左上展示工作区的修改，选择文件后右上可以看见内容
* 右下在提交前输入提交信息，点击提交
* 提交：可以看到在当前分支上创建了一个新提交记录

推送：

* ==push，上方已经remote了，所以没有任何错误
* 在GitHub上可以看到新增了一个分支，里面包含新的修改，而默认的分支则没有修改

合并：

* 当我们切换到v2分支时，发现工作区并没有文件1
* 选择合并分行：选择要合并到当前分支的那个分支，如果选择单一分支线 == rebase，选择总是建立新的合并提交==merge

推送：

* 将v2推送到远程
* 这样远程中的v2也包含了文件1

合并到主分支：

* 当我们远程切换到master分支时发现不包含文件1
* 切换到master分支，将v1合并到当前分支，再推送
* 这样远程的3个分支都包含了所有的修改

* 还可以在GitHub上直接拉取合并pull requests可以将分支合并到当前分支上，首先点pull再点merge


**用git命令复刻上述流程：**

创建仓库：

```c++
……略
git clone < url >
```

在v1分支修改并推送：

```c++
git branch v1
git checkout v1
git add *
git commit -m"在v1添加了文件1"
git push origin v1
```

在v2分支合并并推送：

```c++
git branch v2
git checkout v2
git merge v1
git push origin v2
```

在master分支合并：

```c++
……略
```
