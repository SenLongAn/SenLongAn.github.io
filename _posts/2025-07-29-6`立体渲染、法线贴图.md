---
title: 立体渲染、法线贴图、抗锯齿
date: 2025-07-29 12:00:00 +0800
categories: [OpenGL]
tags: []
math: true
---

## 立体渲染（Stereo-Rendering）

* 一个内容需要被绘制到左眼和右眼的纹理中
* 假设n个物体，每个物体一次drawcall
* Multi-Pass 渲染两张纹理，2n次drawcall
* Single-Pass 渲染一张纹理
* Double Wide 渲染一张双宽度纹理
    * 普通，先渲染一侧，再渲染另一侧，遍历2n次，2n次drawcall
    * ping-pong，每遍历到一个物体，分别在左右侧绘制，遍历n次，节省上下文切换开销，2n次drawcall
* No Double Wide 渲染一张原大小纹理，Index 0 是左眼，Index 1 是右眼，遍历n次，节省上下文切换开销，n次drawcall
    * Instanced 用Instance ID 区分左右眼的 View Matrix
    * MultiView 用gl_ViewID_OVR 区分左右眼的 View Matrix
* Quad-View 
* 它将左右眼画面进一步拆分为 Inner-Left和 Inner-Right，Outer-Left 和 Outer-Right 四个视图
* Outer 画面使用原始的 Fov 进行渲染，Inner 画面则是较小的 FOV
* Inner 画面也会拥有较高的 PPD（Pixels Per Degree），也因此 Inner 画面会有更高的清晰度
* 它有更多的渲染方式
* 渲染4个纹理，遍历4n次，4n次drawcall
* 渲染4个纹理，遍历n次，4n次drawcall
* ……

## 法线贴图

* 通过纹理增加网格细节，且不增加顶点开销，但由于网格表面实际是平整的，所以光照看起来不够真实
* 法线贴图每个像素存储法线方向，xyz用rgb表示，法线贴图大部分是蓝色的，因为法线一般指向z轴
* 光照计算根据法线方向计算，会看到更真实的效果
* 由于法线贴图存储的法线方向永远固定不变，当物体表面方向改变，将获得错误的光照结果
* 局部空间：每个三角形网格独立的空间（原点+坐标系）
* 世界空间：所有三角形网格共用的空间
* 切线空间: 每个三角形网格独立的切线空间，由3个坐标轴TBN组成：tangent(x)、bitangent(y)、normal(z)，T平行三角形表面与U方向对齐，N垂直三角形表面与法线方向一致，B为TN叉乘方向与V方向对齐
* 法线贴图中存储的法线向量在切线空间：对于法线贴图来说它的切线空间为UVN，法线向量在这个切线空间中根据z轴偏移
* TBN矩阵：由三角形网格切线空间3个坐标轴构建的矩阵, 通常需要TBN向量*M变换到世界空间
  * 为什么计算TBN矩阵程序中使用的边并非垂直：计算时使用的边（edge1 和 edge2）并不需要与切线（T）和副切线（B）方向对齐
  * vec3 T = normalize(vec3(model * vec4(tangent,   0.0)));构建的矩阵最后丢弃w不会有问题吗
    * TBN本身是向量vec3，不受位移影响，对于mat4的矩阵，有两种方式，TBN变为vec4 w分量为0、mat3(model)，
    * 对于mat4 * vec4 得到4行1列的向量，因为对于向量来说w分量无意义，所以可以直接丢弃
  * 法线贴图向量*TBN矩阵 从切线空间转换到世界空间
    * ![alt text](/assets/img/blog/Graphic/乘以TBN矩阵.png)
    * mat3 * vec3
    * 法线贴图中存储的法线向量对每个顶点、像素都不一样，像素需要插值计算法线方向，需要在fs中才可以确定下来，只能在fs中转换操作
  * 世界向量*TBN的逆矩阵，根据逆矩阵性质将转换到切线空间
    * 由于像lightpos，viewpos……对于每个像素都一样，在vs中就可以确定下来，可以在顶点着色器中就可以转换操作，由于顶点数量远小于像素数量，可以提高性能
* 法线矩阵:逆转置矩阵:
  * 很多计算是在视图空间进行的，顶点坐标(x,y,z,1)*MV矩阵 变换到视图空间，但法线(x,y,z,0)不能像顶点坐标那样简单变换
  * 法线是向量，位移并不影响向量，直接左乘mat3 可以减少计算量，提高性能
  * 当M矩阵中包含非均匀的缩放时，法线长度改变，但可以单位化修复，法线方向改变，不再垂直于表面，将造成错误的光照计算结果
  * 为什么方向会因为非均匀的缩放发生改变？想象一个平面，连接对角方向，非均匀的缩放对角方向发生改变
  * 逆转置推导
    * 创建原三角形边上的切向量T垂直于N，T 。（点乘）N == 0，
    * 我们希望三角形变换后 GN 。 MT == T' 。 N' == 0, 其中T可以直接*M，矩阵 左 * 向量结果为向量，法线N要特殊的变换G，才能让变换后依旧垂直，我们要求的就是G矩阵
    * GN 。 MT == (GN)^T *(乘法) MT == 0, 两个向量点乘可以变为向量乘法形式
    * (GN)^T * MT == G^T * N^T * M * T, 括号可以展开
    * 当G^T * M == I（单位矩阵）时，GN 。 MT == T' 。 N'（前面的等价） == N^T * T（I被消掉） == N 。T(乘法转为点乘) == 0 , 也就是G^T * M == I时，T' 。 N' == 0，即T' 垂直于 N' 
    * 因此由G^T * M == I，G^T == M^-1, 两边同时转置 G == (M^-1)^T
  * 正交矩阵：A * A^T = I，行列式为1或-1，转置等于逆
  * 当MV矩阵是正交矩阵时，转置等于逆，G == (M^T)^T == M, 法线可以直接用M矩阵

## 抗锯齿
  
* 栅格化：当一个图元的3个顶点投影到屏幕的指定位置，通过遍历所有像素/顶点覆盖的矩形范围像素（优化），确定哪些像素被三角形覆盖，这些像素会进入fs被着色
* 锯齿：由于像素有限数量，通过像素中心采样点作为像素的位置, 在三角形边缘处有的被判断为true，有的判断为false，造成边缘的崎岖
* SSAA
  * 原理：把一个母像素分为n个子像素，对每个子像素正常计算，最后所有图元绘制结束后，子像素的平均值作为母像素的颜色
  * 开销：
    * 内存：depth_buffer和color_buffer 都扩充为 n * 像素数
    * 性能：扩充为原来的n倍
* MSAA
  * 原理：对一个像素增加n个子采样点，对所有采样点栅格化，对至少一个采样点通过测试的像素fs着色，对所有采样点测试，对通过测试的采样点copy像素颜色，最后所有图元绘制结束后，子采样点的平均值作为像素的颜色
  * 开销：
    * 内存：depth_buffer和color_buffer 都扩充为 n * 像素数
    * 性能：相比于SSAA不用对每个子采样点fs着色计算
* FXAA
  * 不同于上面增加像素/采样数量的方式，它通过后处理方式，检测边缘，对其混合处理
  * 优点：集成比较方便，只需要一个 Pass 来实现抗锯齿
  * 缺点：画面会略微有些模糊，光照高频(颜色变化很快)的地方会不稳定，并且在不断改变视角时，会导致一些闪烁
  * 原理：
    * Quality版本(注重质量)：

      ![alt text](/assets/img/blog/Graphic/FXAA方向.png)

      * 排除内部点：计算 当前处理的像素点 和 周围像素点 的亮度对比值，当对比度值超过一定阈值，被判定为边界，需要进行接下来的抗锯齿处理

        ```c++
        float MaxLuma = max(N, E, W, S, M);
        float MinLuma = min(N, E, W, S, M);
        float Contrast =  MaxLuma - MinLuma;
        if(Contrast >= _Threshold)
        ```

        * 确定水平和垂直方向上5个像素点的亮度差（MaxLuma - MinLuma），如果为了结果更精确可以计算对角总共9个像素点，3X3 像素块
        * 亮度值使用亮度公式计算 L = 0.213 * R + 0.715 * G + 0.072 * B，其中绿色对亮度贡献最大
      * 计算混合系数：计算 当前处理的像素点 和 周围像素点的平均亮度 的差值

        ```c++
        float Filter = 2 * (N + E + S + W) + NE + NW + SE + SW;
        Filter = Filter / 12;//加权颜色混合值
        float PixelBlend = abs(Filter -  M);//差值，混合系数
        ```

        * 权重卷积核：距离越远权重越小
        * 变化越剧烈，混合系数越大
      * 确定混合方向：

        ```c++
        //确定混合方向
        float Vertical = abs(N + S - 2 * M) * 2+ abs(NE + SE - 2 * E) + abs(NW + SW - 2 * W);//水平亮度变化幅度
        float Horizontal = abs(E + W - 2 * M) * 2 + abs(NE + NW - 2 * N) + abs(SE + SW - 2 * S);//垂直亮度变化幅度
        bool IsVertical = Vertical > Horizontal;
        //确定步长大小
        float2 PixelStep = IsVertical ? float2(0, _MainTex_TexelSize.y) : float2(_MainTex_TexelSize.x, 0);
        //确定步长方向
        float Positive = abs((IsVertical ? N : E) - M);
        float Negative = abs((IsVertical ? S : W) - M);
        if(Positive < Negative) PixelStep = -PixelStep;
        ```

        * 锯齿边界通常不会是刚好水平或者垂直的，我们要寻找一个最接近的方向
        * 如果水平方向的亮度变化较大，锯齿边界就是垂直的，沿水平方向进行混合；如果垂直方向的亮度变化较大，锯齿边界是水平的，按垂直方向进行混合
        * 确定步长方向，取变化值最大的那个方向
        * 约定：当在垂直方向时，我们约定向上为正，向下为负。在水平方向时，向右为正，向左为负
      * 混合：

        ```c++
        float4 Result = tex2D(_MainTex, UV + PixelStep * PixelBlend);
        ```

        * 当前处理的像素点颜色，为当前纹理坐标 + 混合方向 * 混合系数，的偏移坐标采样
    * 混合系数优化：

        ```c++
        //梯度值
        float Positive = abs((IsHorizontal ? N : E) - M);
        float Negative = abs((IsHorizontal ? S : W) - M);
        float Gradient;
        if(Positive > Negative) ？Gradient = Positive ：Gradient = Negative；

        //相对方向
        float2 EdgeStep = IsVertical ? float2(_MainTex_TexelSize.x, 0) : float2(0, _MainTex_TexelSize.y);

        //计算边界距离
        for(i = 1; i <= _SearchSteps; ++i) {//搜索步长
            PLuminanceDelta = Luminance(tex2D(_MainTex, UVEdge + i * EdgeStep)) - EdgeLuminance;//边界采样（迭代的两侧像素平均值） - 当前处理的两侧像素平均值
            if(abs(PLuminanceDelta) > GradientThreshold) {//abs(差值) > 阈值
                PDistance = i * (IsVertical ? EdgeStep.x : EdgeStep.y);//获得边界距离
                break;
            }
        }
        if(i == _SearchSteps + 1) {//如果超出搜索步长
            PDistance = EdgeStep * _SearchSteps;//限制到边界
        }
        //沿着相反方向搜索，计算NDistance
        for(i = 1; i <= _SearchSteps; ++i) {
          //NDistance……
        }

        //计算混合系数
        if (PDistance < NDistance) {
          EdgeBlend = 0.5f - PDistance / (PDistance + NDistance);//归一化到0——1，反转到0.5—— -0.5
        }else{
          EdgeBlend = 0.5f - NDistance / (PDistance + NDistance);
        }

        //计算最终混合系数
        float FinalBlend = max(PixelBlend, EdgeBlend);
        ```

      * 计算边界距离：
        * 沿着混合方向的相对方向y->x x->y 的两侧搜索
        * 方法一：
          * 梯度值：当前处理的像素和步长方向的像素的亮度差值
          * 阈值：梯度值 * 0.25作为阈值
          * 比较：比较**梯度值**，abs(梯度值) > 阈值，则认为是到达了锯齿的边界
        * 方法二：
          * 阈值：当前处理的像素和步长方向像素点的平均亮度值 * 0.25作为阈值
          * 比较优化：比较**平均值**，比较时可以不用分别对两个像素采样，可以利用双线性过滤，在边界处采样，既两侧像素的平均亮度值，abs(平均值) > 阈值，则认为是到达了锯齿的边界
      * 计算混合系数：根据正负边界距离动态调整混合系数
      * 计算最终混合系数：和之前PixelBlend取最大值
    * Console版本(注重速度)：
      
      ![alt text](/assets/img/blog/Graphic/FXAAConsole版本.png)

      ```c++
      //亮度对比值
      float MaxLuma = max(NW, NE, SW, SE);
      float MinLuma = min(NW, NE, SW, SE);
      float Contrast =  max(MaxLuma, M) -  min(MinLuma, M);
      if(Contrast >= _Threshold)

      //计算混合方向
      Dir.x = -((NW + NE) - (SW + SE));//水平亮度
      Dir.y = ((NE + SE) - (NW + SW));//垂直亮度
      Dir = normalize(Dir);//构成向量，获取方向

      //沿着混合方向采样平均
      float2 Dir1 = Dir * _MainTex_TexelSize.xy;
      float4 N1 = tex2D(_MainTex, UV + Dir1);
      float4 P1 = tex2D(_MainTex, UV - Dir1);
      float4 Result = (N1 + P1) * 0.5f;

      //优化
      float DirAbsMinTimesC = min(abs(Dir.x), abs(Dir.y)) * _Sharpness;//越水平，结果越小
      float2 Dir2 = clamp(Dir1 / DirAbsMinTimesC, -2, 2) * 2;//分母越小，值越大

      float2 Dir2 = Dir2 * _MainTex_TexelSize.xy;
      float4 N2 = tex2D(_MainTex, UV + Dir2);
      float4 P2 = tex2D(_MainTex, UV - Dir2);
      float4 Result2 = Result * 0.5f + (N2 + P2) * 0.25f;//和上次结果加权混合

      if(Luminance(Result2.xyz) > MinLuma && Luminance(Result2.xyz) < MaxLuma) {//检测是否在亮度范围中
          Result = Result2;
      }
      ```
      
      * 采样点：M像素的四个顶点位置，是圆点所有覆盖像素的亮度平均值
      * 排除内部点：……同上
      * 计算混合方向
      * 计算像素结果：沿着混合方向采样平均
      * 优化混合系数：
        * 上述对于水平/垂直锯齿不友好
        * 对Dir的最小值的倒数对Dir1缩放，获得Dir2
        * 如果切向方向越接近水平或者垂直方向，那么采样的距离缩放值就越大
        * 和上次结果加权混合
        * 检测是否在亮度范围中，否则丢弃