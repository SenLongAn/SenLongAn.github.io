---
title: c++(9·强制转换，)
date: 2025-04-14 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---
# 强制转换

类型转换：将一种数据类型转换为另一种数据类型

四个C++ 显示/强制 类型转换运算符，相比于C风格强制转换，它更加规范、清晰

#### C风格转换

```c++
double pi = 3.14159;
int truncatedPi = pi;//double 转换为 int

uintptr_t address = (uintptr_t)ptr;//将指针转换为整数类型
int *newPtr = (int*)address;//将整数转换回指针
```

* 隐式类型转化：编译器在编译阶段自动进行，会类型检查，检查失败则编译失败，可能数据精度丢失
* 显式类型转化：跳过类型检查，可能导致严重的运行时错误或未定义行为，并且它的代码不够清晰

#### 隐式 vs. 显示

* 显示可以避免意外转换，从而产生符合预期的转换方式
* 显示让代码更明确清晰，提高可维护性

#### static_cast 静态转换

编译时转换，不会进行 类型检查(编译运行时检查合法性),可能造成运行时崩溃

```c++
int num = 97;
char ch = static_cast<char>(num);

int value = 42;
int* intPtr = &value;
int* ptr = nullptr;
void* voidPtr = static_cast<void*>(intPtr);
int* newIntPtr = static_cast<int*>(voidPtr);
void* voidPtr = static_cast<void*>(ptr);


class Animal {
public:
    virtual void sound() const {
        std::cout << "Animal makes a sound" << std::endl;
    }
};
 
class Dog : public Animal {
public:
    void sound() const override {
        std::cout << "Dog barks" << std::endl;
    }
    void fetch() const {
        std::cout << "Dog fetches the ball" << std::endl;
    }
};

Dog myDog;
Animal* animalPtr = static_cast<Animal*>(&myDog);  // 安全的上行转换
animalPtr->sound();  // 调用的是 Dog 的 sound

Animal* animalPtr = new Animal(); 
Dog* dogPtr = static_cast<Dog*>(animalPtr);//不安全
dogPtr->sound();  // 调用 Animal 的 sound 方法
dogPtr->fetch();  //未定义行为

Animal* animalPtr = new Dog();  // Animal指针指向Dog对象
Dog* dogPtr = static_cast<Dog*>(animalPtr);  // 下行转换
dogPtr->sound();  // 调用 Dog 的 sound 方法
dogPtr->fetch();  // 调用 Dog 的 fetch 方法
```

* C++中内置类型之间的相互转换
  * 浮点 -> 整形， 整形 -> 浮点
  * 整形/浮点不同精度
  * 字符 -> 整形 ， 整形 -> 字符
  * 有类型的指针，无类型指针，相互转换
* 对有继承关系的类的指针或引用进行强制转换

#### dynamic_cast 动态转换

运行时转换，会进行运行时类型检查，专门用于处理继承体系间的转换，它是更安全的

多态类之间的向下转换，要求父类中至少有一个虚函数，并且父类指针实际指向子类对象，才会转换成功，如果转换失败返回nullptr指针

```c++
Dog myDog;
Animal* animalPtr = dynamic_cast<Animal*>(&myDog);  // 上行转换（子类到父类）
animalPtr->sound();//调用子类方法

Animal* animalPtr = new Dog();
Dog* dogPtr = dynamic_cast<Dog*>(animalPtr);//父类指针转换为子类指针 
if (dogPtr) {  // 如果转换成功
    dogPtr->sound();  // 输出: Dog barks
    dogPtr->fetch();      // 输出: Dog fetches the ball
} else {
    std::cout << "Conversion failed!" << std::endl;
}

```

#### const_cast 常量转换

* 移除 指向常数对象的指针或引用的常量性     常量 -> 非常量
* 添加 指向非常数对象的指针或引用的常量性   非常量 -> 常量
* 不能用于在不同类型之间进行转换
* 必须谨慎使用

```c++
void modify(int* p) 
{
    *p = 100;  // 修改指针指向的值
}

const int a = 10;
const int * p = &a;
modify(const_cast<int*>(p));//试图修改常量对象，不安全，可能导致未定义行为

int b = 20;  
const int* p = &b;
modify(const_cast<int*>(p));//试图修改非常量对象，安全修改 b = 100

void print(const int* p) {
    std::cout << "Value: " << *p << std::endl;
}
int c = 50;
int* p = &c;
print(const_cast<const int*>(p));//非常量转换为常量是安全的
```

#### reinterpret_cast 重新解释转换

不同类型之间进行低级别（二进制）的类型转换, 它有更强大的转换功能，但最不安全

```c++
A* objA;
B* bPtr = reinterpret_cast<B*>(objA);
bPtr->display();//强行转换不相关类型，可能导致内存错误和未定义行为

int x = 42;
uintptr_t* address = reinterpret_cast<uintptr_t*>(&x);//如果修改了x的值足够大，转换为int，可能会导致非法的内存访问
int newV = reinterpret_cast<int>(address);

float f = 3.14f;
int* intPtr = reinterpret_cast<int*>(&f);// 输出 f 的位模式所代表的整数，结果可能非常难以理解
```

* 指针类型之间的转换：将一个指针类型转换为另一个指针类型
* 指针和整数之间的转换：允许将指针转换为整数类型，或将整数转换为指针类型
* 非相关类型之间的转换：在不相关的类型之间进行转换

# 回调(callback)

它有别于直接调用 被调用者，而通过调用调用者 间接调用关联的被调用者，也就是它是由调用者触发的

可调用对象：可以通过调用运算符()调用

* 函数对象，普通函数
* 函数指针
  * ReturnType (*PointerName)(ParameterTypes...);
  * PointerName = FunctionName，将函数赋值给函数指针
  * PointerName() / (*PointerName)()调用 
* lambda/匿名表达式：
  * [capture list] (parameter list) -> return type { function body }
  * [capture list]: 
    * lambda默认情况不能像普通函数一样使用外部变量，可以通过capture list / 参数形式传递进来
    * []：默认不捕获任何变量；
    * [ x ]：仅以值捕获x，其它变量不捕获；并非像 参数/外部变量 那样调用时才拷贝，而是被创建时拷贝
    * [&x]：仅以引用捕获x，其它变量不捕获；
    * [=]：默认以值捕获所有变量；
    * [&]：默认以引用捕获所有变量；
    * [=, &x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；
    * [&, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；
  * 作用/优势：
    * 提供局部变量“捕获”功能，因为普通函数不能在另一个函数内定义，只能通过参数传递，而lambda可以一键捕获所有局部变量
    * 可以赋值给函数指针，并通过()调用，还可以使用 auto f = ……，自动推断
    * 
* 函数对象：重载了operator() 的类
* 模板函数对象

实现回调的方式：

* 函数指针
  * 可通过函数指针将一个被调用者作为参数传递给调用者
* std::function
* std::bind
