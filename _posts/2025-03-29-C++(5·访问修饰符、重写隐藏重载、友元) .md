---
title: c++(5·访问修饰符、重写隐藏重载、友元)
date: 2025-03-29 12:00:00 +0800
categories: [C++]
tags: []     # TAG names should always be lowercase
math: true
---
# 成员访问修饰符

**作用**

控制着类成员的**访问 == 调用**权限

**分类：**

* public公共：在类内，类外（类定义外），派生类，友元，都可以访问，通常存放对外公开的接口
* protected受保护：在类内，派生类，友元可以访问，通常存放在继承体系中可以访问的部分
* private私有：只能在类内，友元，可以访问，通常存放对类外隐藏实现的部分

**访问修饰符和继承：**

注意：访问修饰符并不会影响派生类是否可以 继承/隐藏/重写（即使是private的），只是影响是否能被访问

# 函数隐藏、重写……概念区分

注：仅声明不算实现
* 函数签名：函数名、参数类型、参数个数、参数顺序、const、volatile……属于函数签名，返回类型、virtual、override、final……不属于函数签名
* 不同函数：同作用域中，函数名不同，函数签名不同（即除了函数名外的函数签名特性可相同可不同）
* 重复定义：同作用域中，函数签名相同（即函数签名所有特性均相同）
* 重载：同作用域中，函数名相同，函数签名不同（即除了函数名外的函数签名特性至少有一项不同）
* 继承体系专有：
  * 继承：不同作用域中,派生类没有同名函数, 特殊成员函数不会继承，会生成类的特有定义
  * 新增：不同作用域中,基类没有同名函数
  * 隐藏：（不支持多态）
    * 不同作用域中,派生类有同名函数，函数签名不同，且基类可有可没有virtual
    * 不同作用域中,函数签名相同，且基类没有virtual
  * 重写：（支持多态）
    * 不同作用域中，函数签名和返回值都要相同，基类有virtual
    * 协变:不同作用域中，函数签名相同，派生类函数返回类型必须是基类函数返回类型的子类型，基类有virtual
  * 不合理情况: 不同作用域中，函数签名相同，返回类型不同且非协变，基类有virtual，编译错误

# 示例

```c++
class Base {
public:
    void func() {}
    void func1() {}
    void func1(float x) {}  
private:  
    void func(int x) {}
    void func1(int x) {}  
    virtual void func2() {}
};

class Derived : public Base {
public:
    void func1() {}
    void func2() {}
};
```

**上述流程：**

* func:
  * base中定义了2个重载版本，都会被Derived继承，
  * 由于第2个版本为private，因此不能被derived调用
* func1:
  * base中定义了3个重载版本，都会被Derived隐藏，
  * 当在derived内直接调用func1时只能调用derived中的func1版本，但可以Base::func1 （作用域解析运算符）显式调用基类中的版本，
  * base private的部分不能被外部调用，但是base public部分可以被外部调用，derived部分可以被外部调用
* func2:
  * base中定义了1个版本，会被Derived重写，
  * **外部代码不能通过基类指针/引用直接调用 private virtual 方法，即使实际类型是派生类对象，且在派生类中修改权限为private**（可以用于“不想对外暴露 virtual 函数，而提供一个 public 的非虚函数给外界访问”的情形）
  * 如果想要在外面调用，基类以及派生类必须都为public的
  * 如果仅想调用派生类public virtual func2的，则需要创建派生类对象调用

# 继承访问修饰符

**作用**

控制派生类对象对基类成员的访问权限

**分类**

private部分由于没有访问权限所以我们直接忽略

* public 继承：基类的 public 和 protected 成员在派生类中保持原有访问权限
* protected 继承：基类的 public 和 protected 成员在派生类中变为protected
* private 继承（默认）：基类的 public 和 protected 成员在派生类中变为private

# 友元

**作用：**

通过friend声明为友元，允许某个外部函数/类访问当前类的 private 和 protected 成员

**分类：**

```c++
class Box {
public:
    Box(int w) : width(w) {}
    // 声明友元函数
    friend void printWidth(Box box);
    // 声明友元类
    friend class Printer;
private:
    int width;
};

void printWidth(Box box) {
    cout << "Box width: " << box.width << endl;
}
class Printer {
public:
    void printWidth(Box box) {
        cout << "Box width: " << box.width << endl;
    }
};
```

* 友元函数：
* 友元类：

**特点：**

* 友元关系是单向的,如果 A 是 B 的友元，B 是 C 的友元，A 不会自动成为 C 的友元
* 不能继承，基类的友元不是派生类的友元
* 不受访问修饰符影响，friend 声明可以放在 public、protected 或 private 区域，不影响其友元的性质
